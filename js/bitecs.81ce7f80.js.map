{"version":3,"file":"js/bitecs.81ce7f80.js","mappings":"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","sources":["webpack://ecs-arraybuffer/./node_modules/@timohausmann/quadtree-ts/src/Quadtree.ts","webpack://ecs-arraybuffer/./node_modules/@timohausmann/quadtree-ts/src/Rectangle.ts","webpack://ecs-arraybuffer/./src/math/distance.ts","webpack://ecs-arraybuffer/./src/math/euclidean-distance.ts","webpack://ecs-arraybuffer/../src/Constants.js","webpack://ecs-arraybuffer/../src/Storage.js","webpack://ecs-arraybuffer/../src/Util.js","webpack://ecs-arraybuffer/../src/Serialize.js","webpack://ecs-arraybuffer/../src/Entity.js","webpack://ecs-arraybuffer/../src/Query.js","webpack://ecs-arraybuffer/../src/Component.js","webpack://ecs-arraybuffer/../src/World.js","webpack://ecs-arraybuffer/../src/index.js","webpack://ecs-arraybuffer/./src/bitecs/entities/entity.ts","webpack://ecs-arraybuffer/./src/bitecs/entities/station.ts","webpack://ecs-arraybuffer/./src/bitecs/entities/ship.ts","webpack://ecs-arraybuffer/./src/bitecs/systems/spawn-ship-system.ts","webpack://ecs-arraybuffer/./src/bitecs/components/position.ts","webpack://ecs-arraybuffer/./src/bitecs/components/controller.ts","webpack://ecs-arraybuffer/./src/bitecs/components/velocity.ts","webpack://ecs-arraybuffer/./src/bitecs/components/health.ts","webpack://ecs-arraybuffer/./src/bitecs/components/controlled.ts","webpack://ecs-arraybuffer/./src/bitecs/components/attack.ts","webpack://ecs-arraybuffer/./src/bitecs/components/index.ts","webpack://ecs-arraybuffer/./src/bitecs/systems/velocity-system.ts","webpack://ecs-arraybuffer/./src/bitecs/systems/collision-system.ts","webpack://ecs-arraybuffer/./src/bitecs/systems/target-enemy-system.ts","webpack://ecs-arraybuffer/./src/bitecs/systems/create-quad-tree-system.ts","webpack://ecs-arraybuffer/./src/bitecs/systems/update-health-timers-system.ts","webpack://ecs-arraybuffer/./src/bitecs/systems/move-to-target-system.ts","webpack://ecs-arraybuffer/./src/bitecs/entities/world.ts","webpack://ecs-arraybuffer/./node_modules/vue-loader/dist/index.js","webpack://ecs-arraybuffer/./src/bitecs/BitECSGame.vue"],"sourcesContent":["import type { NodeGeometry, Indexable } from './types';\nimport type { Rectangle } from './Rectangle';\nimport type { Circle } from './Circle';\nimport type { Line } from './Line';\n\n/**\n * Quadtree Constructor Properties\n */\nexport interface QuadtreeProps {\n\n    /**\n     * Width of the node.\n     */\n    width: number\n\n    /**\n     * Height of the node.\n     */\n    height: number\n\n    /**\n     * X Offset of the node.\n     * @defaultValue `0`\n     */\n    x?: number\n\n    /**\n     * Y Offset of the node.\n     * @defaultValue `0`\n     */\n    y?: number\n\n    /**\n     * Max objects this node can hold before it splits.\n     * @defaultValue `10`\n     */\n    maxObjects?: number\n\n    /**\n     * Total max nesting levels of the root Quadtree node.\n     * @defaultValue `4`\n     */\n    maxLevels?: number\n}\n\n/**\n * Class representing a Quadtree node.\n * \n * @example\n * ```typescript\n * const tree = new Quadtree({\n *   width: 100,\n *   height: 100,\n *   x: 0,           // optional, default:  0\n *   y: 0,           // optional, default:  0\n *   maxObjects: 10, // optional, default: 10\n *   maxLevels: 4,   // optional, default:  4\n * });\n * ```\n * \n * @example Typescript: If you like to be explicit, you optionally can pass in a generic type for objects to be stored in the Quadtree:\n * ```typescript\n * class GameEntity extends Rectangle {\n *   ...\n * }\n * const tree = new Quadtree<GameEntity>({\n *   width: 100,\n *   height: 100,\n * });\n * ```\n */\nexport class Quadtree<ObjectsType extends Rectangle|Circle|Line|Indexable> {\n\n    /**\n     * The numeric boundaries of this node.\n     * @readonly\n     */\n    bounds: NodeGeometry;\n\n    /**\n     * Max objects this node can hold before it splits.\n     * @defaultValue `10`\n     * @readonly\n     */\n    maxObjects: number;\n    \n    /**\n     * Total max nesting levels of the root Quadtree node.\n     * @defaultValue `4`\n     * @readonly\n     */\n    maxLevels: number;\n\n    /**\n     * The level of this node.\n     * @defaultValue `0`\n     * @readonly\n     */\n    level: number;\n\n    /**\n     * Array of objects in this node.\n     * @defaultValue `[]`\n     * @readonly\n     */\n    objects: ObjectsType[];\n\n    /**\n     * Subnodes of this node\n     * @defaultValue `[]`\n     * @readonly\n     */\n    nodes: Quadtree<ObjectsType>[];\n\n    /**\n     * Quadtree Constructor\n     * @param props - bounds and properties of the node\n     * @param level - depth level (internal use only, required for subnodes)\n     */\n    constructor(props:QuadtreeProps, level=0) {\n        \n        this.bounds = { \n            x: props.x || 0, \n            y: props.y || 0, \n            width: props.width, \n            height: props.height,\n        };\n        this.maxObjects = (typeof props.maxObjects === 'number') ? props.maxObjects : 10;\n        this.maxLevels  = (typeof props.maxLevels === 'number') ? props.maxLevels : 4;\n        this.level      = level;\n        \n        this.objects = [];\n        this.nodes   = [];\n    }\n    \n    /**\n     * Get the quadrant (subnode indexes) an object belongs to.\n     * \n     * @example Mostly for internal use but you can call it like so:\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * const rectangle = new Rectangle({ x: 25, y: 25, width: 10, height: 10 });\n     * const indexes = tree.getIndex(rectangle);\n     * console.log(indexes); // [1]\n     * ```\n     * \n     * @param obj - object to be checked\n     * @returns Array containing indexes of intersecting subnodes (0-3 = top-right, top-left, bottom-left, bottom-right).\n     */\n    getIndex(obj:ObjectsType): number[] {\n        return obj.qtIndex(this.bounds);\n    }\n\n    /**\n     * Split the node into 4 subnodes.\n     * @internal\n     * \n     * @example Mostly for internal use! You should only call this yourself if you know what you are doing:\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * tree.split();\n     * console.log(tree); // now tree has four subnodes\n     * ```\n     */\n    split(): void {\n        \n        const level = this.level + 1,\n            width   = this.bounds.width/2,\n            height  = this.bounds.height/2,\n            x       = this.bounds.x,\n            y       = this.bounds.y;\n\n        const coords = [\n            { x: x + width, y: y },\n            { x: x,         y: y },\n            { x: x,         y: y + height },\n            { x: x + width, y: y + height },\n        ];\n\n        for(let i=0; i < 4; i++) {\n            this.nodes[i] = new Quadtree({\n                x: coords[i].x, \n                y: coords[i].y, \n                width,\n                height,\n                maxObjects: this.maxObjects,\n                maxLevels: this.maxLevels,\n            }, level);\n        }        \n    }\n\n\n    /**\n     * Insert an object into the node. If the node\n     * exceeds the capacity, it will split and add all\n     * objects to their corresponding subnodes.\n     * \n     * @example you can use any shape here (or object with a qtIndex method, see README):\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * tree.insert(new Rectangle({ x: 25, y: 25, width: 10, height: 10, data: 'data' }));\n     * tree.insert(new Circle({ x: 25, y: 25, r: 10, data: 512 }));\n     * tree.insert(new Line({ x1: 25, y1: 25, x2: 60, y2: 40, data: { custom: 'property'} }));\n     * ```\n     * \n     * @param obj - Object to be added.\n     */\n    insert(obj:ObjectsType): void {\n        \n        //if we have subnodes, call insert on matching subnodes\n        if(this.nodes.length) {\n            const indexes = this.getIndex(obj);\n    \n            for(let i=0; i<indexes.length; i++) {\n                this.nodes[indexes[i]].insert(obj);\n            }\n            return;\n        }\n    \n        //otherwise, store object here\n        this.objects.push(obj);\n\n        //maxObjects reached\n        if(this.objects.length > this.maxObjects && this.level < this.maxLevels) {\n\n            //split if we don't already have subnodes\n            if(!this.nodes.length) {\n                this.split();\n            }\n            \n            //add all objects to their corresponding subnode\n            for(let i=0; i<this.objects.length; i++) {\n                const indexes = this.getIndex(this.objects[i]);\n                for(let k=0; k<indexes.length; k++) {\n                    this.nodes[indexes[k]].insert(this.objects[i]);\n                }\n            }\n\n            //clean up this node\n            this.objects = [];\n        }\n    }\n    \n    \n    /**\n     * Return all objects that could collide with the given geometry.\n     * \n     * @example Just like insert, you can use any shape here (or object with a qtIndex method, see README):\n     * ```typescript \n     * tree.retrieve(new Rectangle({ x: 25, y: 25, width: 10, height: 10, data: 'data' }));\n     * tree.retrieve(new Circle({ x: 25, y: 25, r: 10, data: 512 }));\n     * tree.retrieve(new Line({ x1: 25, y1: 25, x2: 60, y2: 40, data: { custom: 'property'} }));\n     * ```\n     * \n     * @param obj - geometry to be checked\n     * @returns Array containing all detected objects.\n     */\n    retrieve(obj:ObjectsType): ObjectsType[] {\n        \n        const indexes = this.getIndex(obj);\n        let returnObjects = this.objects;\n            \n        //if we have subnodes, retrieve their objects\n        if(this.nodes.length) {\n            for(let i=0; i<indexes.length; i++) {\n                returnObjects = returnObjects.concat(this.nodes[indexes[i]].retrieve(obj));\n            }\n        }\n\n        //remove duplicates\n        returnObjects = returnObjects.filter(function(item, index) {\n            return returnObjects.indexOf(item) >= index;\n        });\n    \n        return returnObjects;\n    }\n\n\n    /**\n     * Clear the Quadtree.\n     * \n     * @example\n     * ```typescript\n     * const tree = new Quadtree({ width: 100, height: 100 });\n     * tree.insert(new Circle({ x: 25, y: 25, r: 10 }));\n     * tree.clear();\n     * console.log(tree); // tree.objects and tree.nodes are empty\n     * ```\n     */\n    clear(): void {\n        \n        this.objects = [];\n    \n        for(let i=0; i < this.nodes.length; i++) {\n            if(this.nodes.length) {\n                this.nodes[i].clear();\n            }\n        }\n\n        this.nodes = [];\n    }\n}","import type { NodeGeometry, Indexable } from './types';\n\n/**\n * Rectangle Geometry\n * @beta\n * \n * @remarks\n * This interface simply represents a rectangle geometry.\n */\nexport interface RectangleGeometry {\n\n    /**\n     * X start of the rectangle (top left).\n     */\n    x: number\n\n    /**\n     * Y start of the rectangle (top left).\n     */\n    y: number\n\n    /**\n     * Width of the rectangle.\n     */\n    width: number\n\n    /**\n     * Height of the rectangle.\n     */\n    height: number\n}\n\n/**\n * Rectangle Constructor Properties\n * @beta\n * @typeParam CustomDataType - Type of the custom data property (optional, inferred automatically).\n */\nexport interface RectangleProps<CustomDataType = void> extends RectangleGeometry {\n\n    /**\n     * Custom data\n     */\n    data?: CustomDataType\n}\n\n/**\n * Class representing a Rectangle\n * @typeParam CustomDataType - Type of the custom data property (optional, inferred automatically).\n * \n * @example Without custom data (JS/TS):\n * ```typescript\n * const rectangle = new Rectangle({ \n *   x: 10, \n *   y: 20, \n *   width: 30,\n *   height: 40,\n * });\n * ```\n * \n * @example With custom data (JS/TS):\n * ```javascript\n * const rectangle = new Rectangle({ \n *   x: 10, \n *   y: 20, \n *   width: 30,\n *   height: 40,\n *   data: { \n *     name: 'Jane', \n *     health: 100,\n *   },\n * });\n * ```\n * \n * @example With custom data (TS):\n * ```typescript\n * interface ObjectData {\n *   name: string\n *   health: number\n * }\n * const entity: ObjectData = {\n *   name: 'Jane',\n *   health: 100,\n * };\n * \n * // Typescript will infer the type of the data property\n * const rectangle1 = new Rectangle({\n *   x: 10, \n *   y: 20, \n *   width: 30,\n *   height: 40,\n *   data: entity,\n * });\n * \n * // You can also pass in a generic type for the data property\n * const rectangle2 = new Rectangle<ObjectData>({ \n *   x: 10, \n *   y: 20, \n *   width: 30,\n *   height: 40,\n * });\n * rectangle2.data = entity;\n * ```\n * \n * @example With custom class extending Rectangle (implements {@link RectangleGeometry} (x, y, width, height)):\n * ```javascript\n * // extending inherits the qtIndex method\n * class Box extends Rectangle {\n *   \n *   constructor(props) {\n *     // call super to set x, y, width, height (and data, if given)\n *     super(props);\n *     this.content = props.content;\n *   }\n * }\n * \n * const box = new Box({\n *   content: 'Gravity Boots',\n *   x: 10, \n *   y: 20, \n *   width: 30,\n *   height: 40,\n * });\n * ```\n * \n * @example With custom class and mapping {@link RectangleGeometry}:\n * ```javascript\n * // no need to extend if you don't implement RectangleGeometry\n * class Box {\n *   \n *   constructor(content) {\n *     this.content = content;\n *     this.position = [10, 20];\n *     this.size = [30, 40];\n *   }\n *   \n *   // add a qtIndex method to your class\n *   qtIndex(node) {\n *     // map your properties to RectangleGeometry\n *     return Rectangle.prototype.qtIndex.call({\n *       x: this.position[0],\n *       y: this.position[1],\n *       width: this.size[0],\n *       height: this.size[1],\n *     }, node);\n *   }\n * }\n * \n * const box = new Box('Gravity Boots');\n * ```\n * \n * @example With custom object that implements {@link RectangleGeometry}:\n * ```javascript\n * const player = {\n *   name: 'Jane', \n *   health: 100,\n *   x: 10, \n *   y: 20, \n *   width: 30,\n *   height: 30,\n *   qtIndex: Rectangle.prototype.qtIndex,\n * });\n * ```\n * \n * @example With custom object and mapping {@link RectangleGeometry}:\n * ```javascript\n * // Note: this is not recommended but possible. \n * // Using this technique, each object would have it's own qtIndex method. \n * // Rather add qtIndex to your prototype, e.g. by using classes like shown above.\n * const player = {\n *   name: 'Jane', \n *   health: 100,\n *   position: [10, 20], \n *   size: [30, 40], \n *   qtIndex: function(node) {\n *     return Rectangle.prototype.qtIndex.call({\n *       x: this.position[0],\n *       y: this.position[1],\n *       width: this.size[0],\n *       height: this.size[1],\n *     }, node);\n *   },\n * });\n * ```\n */\nexport class Rectangle<CustomDataType = void> implements RectangleGeometry, Indexable {\n\n    /**\n     * X start of the rectangle (top left).\n     */\n    x: number;\n\n    /**\n     * Y start of the rectangle (top left).\n     */\n    y: number;\n\n    /**\n     * Width of the rectangle.\n     */\n    width: number;\n\n    /**\n     * Height of the rectangle.\n     */\n    height: number;\n\n    /**\n     * Custom data.\n     */\n    data?: CustomDataType;\n\n    constructor(props:RectangleProps<CustomDataType>) {\n        \n        this.x = props.x;\n        this.y = props.y;\n        this.width = props.width;\n        this.height = props.height;\n        this.data = props.data;\n    }\n    \n    /**\n     * Determine which quadrant this rectangle belongs to.\n     * @param node - Quadtree node to be checked\n     * @returns Array containing indexes of intersecting subnodes (0-3 = top-right, top-left, bottom-left, bottom-right)\n     */\n    qtIndex(node:NodeGeometry): number[] {\n        \n        const indexes:number[] = [],\n            boundsCenterX   = node.x + (node.width/2),\n            boundsCenterY   = node.y + (node.height/2);\n\n        const startIsNorth  = this.y < boundsCenterY,\n            startIsWest     = this.x < boundsCenterX,\n            endIsEast       = this.x + this.width > boundsCenterX,\n            endIsSouth      = this.y + this.height > boundsCenterY;\n\n        //top-right quad\n        if(startIsNorth && endIsEast) {\n            indexes.push(0);\n        }\n        \n        //top-left quad\n        if(startIsWest && startIsNorth) {\n            indexes.push(1);\n        }\n\n        //bottom-left quad\n        if(startIsWest && endIsSouth) {\n            indexes.push(2);\n        }\n\n        //bottom-right quad\n        if(endIsEast && endIsSouth) {\n            indexes.push(3);\n        }\n     \n        return indexes;\n    }\n}","export default function distance(x1: number, y1: number, x2: number, y2: number): number {\n\treturn Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);\n}","export default function euclideanDistance(x1: number, y1: number, x2: number, y2: number): number {\n\treturn (x1 - x2) ** 2 + (y1 - y2) ** 2;\n}","export const TYPES_ENUM = {\n  i8: 'i8',\n  ui8: 'ui8',\n  ui8c: 'ui8c',\n  i16: 'i16',\n  ui16: 'ui16',\n  i32: 'i32',\n  ui32: 'ui32',\n  f32: 'f32',\n  f64: 'f64',\n  eid: 'eid',\n}\n\nexport const TYPES_NAMES = {\n  i8: 'Int8',\n  ui8: 'Uint8',\n  ui8c: 'Uint8Clamped',\n  i16: 'Int16',\n  ui16: 'Uint16',\n  i32: 'Int32',\n  ui32: 'Uint32',\n  eid: 'Uint32',\n  f32: 'Float32',\n  f64: 'Float64'\n}\n\nexport const TYPES = {\n  i8: Int8Array,\n  ui8: Uint8Array,\n  ui8c: Uint8ClampedArray,\n  i16: Int16Array,\n  ui16: Uint16Array,\n  i32: Int32Array,\n  ui32: Uint32Array,\n  f32: Float32Array,\n  f64: Float64Array,\n  eid: Uint32Array,\n}\n\nexport const UNSIGNED_MAX = {\n  uint8: 2**8,\n  uint16: 2**16,\n  uint32: 2**32\n}\n","import { TYPES, TYPES_ENUM, TYPES_NAMES, UNSIGNED_MAX } from './Constants.js'\n// import { createAllocator } from './Allocator.js'\n\nconst roundToMultiple = mul => x => Math.ceil(x / mul) * mul\nconst roundToMultiple4 = roundToMultiple(4)\n\nexport const $storeRef = Symbol('storeRef')\nexport const $storeSize = Symbol('storeSize')\nexport const $storeMaps = Symbol('storeMaps')\nexport const $storeFlattened = Symbol('storeFlattened')\nexport const $storeBase = Symbol('storeBase')\nexport const $storeType = Symbol('storeType')\n\nexport const $storeArrayElementCounts = Symbol('storeArrayElementCounts')\nexport const $storeSubarrays = Symbol('storeSubarrays')\nexport const $subarrayCursors = Symbol('subarrayCursors')\nexport const $subarray = Symbol('subarray')\nexport const $subarrayFrom = Symbol('subarrayFrom')\nexport const $subarrayTo = Symbol('subarrayTo')\nexport const $parentArray = Symbol('parentArray')\nexport const $tagStore = Symbol('tagStore')\n\nexport const $queryShadow = Symbol('queryShadow')\nexport const $serializeShadow = Symbol('serializeShadow')\n\nexport const $indexType = Symbol('indexType')\nexport const $indexBytes = Symbol('indexBytes')\n\nexport const $isEidType = Symbol('isEidType')\n\nconst stores = {}\n\n// const alloc = createAllocator()\n\nexport const resize = (ta, size) => {\n  const newBuffer = new ArrayBuffer(size * ta.BYTES_PER_ELEMENT)\n  const newTa = new ta.constructor(newBuffer)\n  newTa.set(ta, 0)\n  return newTa\n}\n\nexport const createShadow = (store, key) => {\n  if (!ArrayBuffer.isView(store)) {\n    const shadowStore = store[$parentArray].slice(0)\n    store[key] = store.map((_,eid) => {\n      const { length } = store[eid]\n      const start = length * eid\n      const end = start + length\n      return shadowStore.subarray(start, end)\n    })\n  } else {\n    store[key] = store.slice(0)\n  }\n}\n\nconst resizeSubarray = (metadata, store, storeSize) => {\n  const cursors = metadata[$subarrayCursors]\n  let type = store[$storeType]\n  const length = store[0].length\n  const indexType =\n    length <= UNSIGNED_MAX.uint8\n      ? TYPES_ENUM.ui8\n      : length <= UNSIGNED_MAX.uint16\n        ? TYPES_ENUM.ui16\n        : TYPES_ENUM.ui32\n\n  if (cursors[type] === 0) {\n\n    const arrayElementCount = metadata[$storeArrayElementCounts][type]\n    \n    // // for threaded impl\n    // // const summedBytesPerElement = Array(arrayCount).fill(0).reduce((a, p) => a + TYPES[type].BYTES_PER_ELEMENT, 0)\n    // // const totalBytes = roundToMultiple4(summedBytesPerElement * summedLength * size)\n    // // const buffer = new SharedArrayBuffer(totalBytes)\n\n    const array = new TYPES[type](roundToMultiple4(arrayElementCount * storeSize))\n\n    array.set(metadata[$storeSubarrays][type])\n    \n    metadata[$storeSubarrays][type] = array\n    \n    array[$indexType] = TYPES_NAMES[indexType]\n    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\n  }\n\n  const start = cursors[type]\n  const end = start + (storeSize * length)\n  cursors[type] = end\n\n  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end)\n\n  // pre-generate subarrays for each eid\n  for (let eid = 0; eid < storeSize; eid++) {\n    const start = length * eid\n    const end = start + length\n    store[eid] = store[$parentArray].subarray(start, end)\n    store[eid][$indexType] = TYPES_NAMES[indexType]\n    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\n    store[eid][$subarray] = true\n  }\n\n}\n\nconst resizeRecursive = (metadata, store, size) => {\n  Object.keys(store).forEach(key => {\n    const ta = store[key]\n    if (Array.isArray(ta)) {\n      resizeSubarray(metadata, ta, size)\n      store[$storeFlattened].push(ta)\n    } else if (ArrayBuffer.isView(ta)) {\n      store[key] = resize(ta, size)\n      store[$storeFlattened].push(store[key])\n    } else if (typeof ta === 'object') {\n      resizeRecursive(metadata, store[key], size)\n    }\n  })\n}\n\nexport const resizeStore = (store, size) => {\n  if (store[$tagStore]) return\n  store[$storeSize] = size\n  store[$storeFlattened].length = 0\n  Object.keys(store[$subarrayCursors]).forEach(k => {\n    store[$subarrayCursors][k] = 0\n  })\n  resizeRecursive(store, store, size)\n}\n\nexport const resetStore = store => {\n  if (store[$storeFlattened]) {\n    store[$storeFlattened].forEach(ta => {\n      ta.fill(0)\n    })\n    Object.keys(store[$storeSubarrays]).forEach(key => {\n      store[$storeSubarrays][key].fill(0)\n    })\n  }\n}\n\nexport const resetStoreFor = (store, eid) => {\n  if (store[$storeFlattened]) {\n    store[$storeFlattened].forEach(ta => {\n      if (ArrayBuffer.isView(ta)) ta[eid] = 0\n      else ta[eid].fill(0)\n    })\n  }\n}\n\nconst createTypeStore = (type, length) => {\n  const totalBytes = length * TYPES[type].BYTES_PER_ELEMENT\n  const buffer = new ArrayBuffer(totalBytes)\n  const store = new TYPES[type](buffer)\n  store[$isEidType] = type === TYPES_ENUM.eid\n  return store\n}\n\nexport const parentArray = store => store[$parentArray]\n\nconst createArrayStore = (metadata, type, length) => {\n  const storeSize = metadata[$storeSize]\n  const store = Array(storeSize).fill(0)\n  store[$storeType] = type\n  store[$isEidType] = type === TYPES_ENUM.eid\n\n  const cursors = metadata[$subarrayCursors]\n  const indexType =\n    length <= UNSIGNED_MAX.uint8\n      ? TYPES_ENUM.ui8\n      : length <= UNSIGNED_MAX.uint16\n        ? TYPES_ENUM.ui16\n        : TYPES_ENUM.ui32\n\n  if (!length) throw new Error('bitECS - Must define component array length')\n  if (!TYPES[type]) throw new Error(`bitECS - Invalid component array property type ${type}`)\n\n  // create buffer for type if it does not already exist\n  if (!metadata[$storeSubarrays][type]) {\n    const arrayElementCount = metadata[$storeArrayElementCounts][type]\n\n    // for threaded impl\n    // const summedBytesPerElement = Array(arrayCount).fill(0).reduce((a, p) => a + TYPES[type].BYTES_PER_ELEMENT, 0)\n    // const totalBytes = roundToMultiple4(summedBytesPerElement * summedLength * size)\n    // const buffer = new SharedArrayBuffer(totalBytes)\n\n    const array = new TYPES[type](roundToMultiple4(arrayElementCount * storeSize))\n    array[$indexType] = TYPES_NAMES[indexType]\n    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\n\n    metadata[$storeSubarrays][type] = array\n    \n  }\n\n  const start = cursors[type]\n  const end = start + (storeSize * length)\n  cursors[type] = end\n\n  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end)\n\n  // pre-generate subarrays for each eid\n  for (let eid = 0; eid < storeSize; eid++) {\n    const start = length * eid\n    const end = start + length\n    store[eid] = store[$parentArray].subarray(start, end)\n    store[eid][$indexType] = TYPES_NAMES[indexType]\n    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\n    store[eid][$subarray] = true\n  }\n\n  return store\n}\n\nconst isArrayType = x => Array.isArray(x) && typeof x[0] === 'string' && typeof x[1] === 'number'\n\nexport const createStore = (schema, size) => {\n  const $store = Symbol('store')\n\n  if (!schema || !Object.keys(schema).length) {\n    // tag component\n    stores[$store] = {\n      [$storeSize]: size,\n      [$tagStore]: true,\n      [$storeBase]: () => stores[$store]\n    }\n    return stores[$store]\n  }\n\n  schema = JSON.parse(JSON.stringify(schema))\n\n  const arrayElementCounts = {}\n  const collectArrayElementCounts = s => {\n    const keys = Object.keys(s)\n    for (const k of keys) {\n      if (isArrayType(s[k])) {\n        if (!arrayElementCounts[s[k][0]]) arrayElementCounts[s[k][0]] = 0\n        arrayElementCounts[s[k][0]] += s[k][1]\n      } else if (s[k] instanceof Object) {\n        collectArrayElementCounts(s[k])\n      }\n    }\n  }\n  collectArrayElementCounts(schema)\n\n  const metadata = {\n    [$storeSize]: size,\n    [$storeMaps]: {},\n    [$storeSubarrays]: {},\n    [$storeRef]: $store,\n    [$subarrayCursors]: Object.keys(TYPES).reduce((a, type) => ({ ...a, [type]: 0 }), {}),\n    [$storeFlattened]: [],\n    [$storeArrayElementCounts]: arrayElementCounts\n  }\n\n  if (schema instanceof Object && Object.keys(schema).length) {\n\n    const recursiveTransform = (a, k) => {\n\n      if (typeof a[k] === 'string') {\n\n        a[k] = createTypeStore(a[k], size)\n        a[k][$storeBase] = () => stores[$store]\n        metadata[$storeFlattened].push(a[k])\n\n      } else if (isArrayType(a[k])) {\n        \n        const [type, length] = a[k]\n        a[k] = createArrayStore(metadata, type, length)\n        a[k][$storeBase] = () => stores[$store]\n        metadata[$storeFlattened].push(a[k])\n        // Object.seal(a[k])\n\n      } else if (a[k] instanceof Object) {\n        \n        a[k] = Object.keys(a[k]).reduce(recursiveTransform, a[k])\n        // Object.seal(a[k])\n        \n      }\n\n      return a\n    }\n\n    stores[$store] = Object.assign(Object.keys(schema).reduce(recursiveTransform, schema), metadata)\n    stores[$store][$storeBase] = () => stores[$store]\n\n    // Object.seal(stores[$store])\n\n    return stores[$store]\n\n  }\n}\n\nexport const free = (store) => {\n  delete stores[store[$storeRef]]\n}","export const Uint32SparseSet = (length) => {\n  const dense = new Uint32Array(length)\n  const sparse = new Uint32Array(length)\n\n  let cursor = 0\n  dense.count = () => cursor + 1\n\n  const has = val => dense[sparse[val]] === val\n\n  const add = val => {\n    if (has(val)) return\n    sparse[val] = cursor\n    dense[cursor] = val\n\n    cursor++\n  }\n\n  const remove = val => {\n    if (!has(val)) return\n    const index = sparse[val]\n    const swapped = dense[cursor]\n    if (swapped !== val) {\n      dense[index] = swapped\n      sparse[swapped] = index\n    }\n\n    cursor--\n  }\n\n  return {\n    add,\n    remove,\n    has,\n    sparse,\n    dense,\n  }\n}\n\nexport const SparseSet = () => {\n  const dense = []\n  const sparse = []\n\n  dense.sort = function (comparator) {\n    const result = Array.prototype.sort.call(this, comparator)\n\n    for(let i = 0; i < dense.length; i++) {\n      sparse[dense[i]] = i\n    }\n    \n    return result\n  }\n\n  const has = val => dense[sparse[val]] === val\n\n  const add = val => {\n    if (has(val)) return\n    sparse[val] = dense.push(val) - 1\n  }\n\n  const remove = val => {\n    if (!has(val)) return\n    const index = sparse[val]\n    const swapped = dense.pop()\n    if (swapped !== val) {\n      dense[index] = swapped\n      sparse[swapped] = index\n    }\n  }\n\n  return {\n    add,\n    remove,\n    has,\n    sparse,\n    dense,\n  }\n}","import { $indexBytes, $indexType, $isEidType, $serializeShadow, $storeBase, $storeFlattened, $tagStore, createShadow } from \"./Storage.js\"\nimport { $componentMap, addComponent, hasComponent } from \"./Component.js\"\nimport { $entityArray, $entitySparseSet, addEntity, eidToWorld } from \"./Entity.js\"\nimport { $localEntities, $localEntityLookup } from \"./World.js\"\nimport { SparseSet } from \"./Util.js\"\n\nexport const DESERIALIZE_MODE = {\n  REPLACE: 0,\n  APPEND: 1,\n  MAP: 2\n}\n\nlet resized = false\n\nexport const setSerializationResized = v => { resized = v }\n\nconst concat = (a,v) => a.concat(v)\nconst not = fn => v => !fn(v)\n\nconst storeFlattened = c => c[$storeFlattened]\nconst isFullComponent = storeFlattened\nconst isProperty = not(isFullComponent)\n\nconst isModifier = c => typeof c === 'function'\nconst isNotModifier = not(isModifier)\n\nconst isChangedModifier = c => isModifier(c) && c()[1] === 'changed'\n\nconst isWorld = w => Object.getOwnPropertySymbols(w).includes($componentMap)\n\nconst fromModifierToComponent = c => c()[0]\n\nexport const canonicalize = target => {\n\n  if (isWorld(target)) return [[],new Map()]\n\n  // aggregate full components\n  const fullComponentProps = target\n    .filter(isNotModifier)\n    .filter(isFullComponent)\n    .map(storeFlattened).reduce(concat, [])\n  \n  // aggregate changed full components\n  const changedComponentProps = target\n    .filter(isChangedModifier).map(fromModifierToComponent)\n    .filter(isFullComponent)\n    .map(storeFlattened).reduce(concat, [])\n\n  // aggregate props\n  const props = target\n    .filter(isNotModifier)\n    .filter(isProperty)\n\n  // aggregate changed props\n  const changedProps = target\n    .filter(isChangedModifier).map(fromModifierToComponent)\n    .filter(isProperty)\n  \n  const componentProps = [...fullComponentProps, ...props, ...changedComponentProps, ...changedProps]\n  const allChangedProps = [...changedComponentProps, ...changedProps].reduce((map,prop) => {\n    const $ = Symbol()\n    createShadow(prop, $)\n    map.set(prop, $)\n    return map\n  }, new Map())\n\n  return [componentProps, allChangedProps]\n}\n\n/**\n * Defines a new serializer which targets the given components to serialize the data of when called on a world or array of EIDs.\n *\n * @param {object|array} target\n * @param {number} [maxBytes=20000000]\n * @returns {function} serializer\n */\nexport const defineSerializer = (target, maxBytes = 20000000) => {\n  const worldSerializer = isWorld(target)\n\n  let [componentProps, changedProps] = canonicalize(target)\n\n  // TODO: calculate max bytes based on target & recalc upon resize\n\n  const buffer = new ArrayBuffer(maxBytes)\n  const view = new DataView(buffer)\n\n  const entityComponentCache = new Map()\n\n  return (ents) => {\n\n    if (resized) {\n      [componentProps, changedProps] = canonicalize(target)\n      resized = false\n    }\n\n    if (worldSerializer) {\n      componentProps = []\n      target[$componentMap].forEach((c, component) => {\n        if (component[$storeFlattened])\n          componentProps.push(...component[$storeFlattened])\n        else componentProps.push(component)\n      })\n    }\n    \n    let world\n    if (Object.getOwnPropertySymbols(ents).includes($componentMap)) {\n      world = ents\n      ents = ents[$entityArray]\n    } else {\n      world = eidToWorld.get(ents[0])\n    }\n\n    let where = 0\n\n    if (!ents.length) return buffer.slice(0, where)\n\n    const cache = new Map()\n\n    // iterate over component props\n    for (let pid = 0; pid < componentProps.length; pid++) {\n      const prop = componentProps[pid]\n      const component = prop[$storeBase]()\n      const $diff = changedProps.get(prop)\n      const shadow = $diff ? prop[$diff] : null\n\n      if (!cache.has(component)) cache.set(component, new Map())\n\n      // write pid\n      view.setUint8(where, pid)\n      where += 1\n\n      // save space for entity count\n      const countWhere = where\n      where += 4\n\n      let writeCount = 0\n      // write eid,val\n      for (let i = 0; i < ents.length; i++) {\n        const eid = ents[i]\n\n        let componentCache = entityComponentCache.get(eid)\n        if (!componentCache) componentCache = entityComponentCache.set(eid, new Set()).get(eid)\n        \n        componentCache.add(eid)\n        \n        const newlyAddedComponent = \n          // if we are diffing\n          shadow \n          // and we have already iterated over this component for this entity\n          // retrieve cached value    \n          && cache.get(component).get(eid)\n          // or if entity did not have component last call\n          || !componentCache.has(component)\n          // and entity has component this call\n          && hasComponent(world, component, eid)\n\n        cache.get(component).set(eid, newlyAddedComponent)\n\n        if (newlyAddedComponent) {\n          componentCache.add(component)\n        } else if (!hasComponent(world, component, eid)) {\n          // skip if entity doesn't have this component\n          componentCache.delete(component)\n          continue\n        } \n\n        \n        const rewindWhere = where\n\n        // write eid\n        view.setUint32(where, eid)\n        where += 4\n\n        // if it's a tag store we can stop here\n        if (prop[$tagStore]) {\n          writeCount++\n          continue\n        }\n\n        // if property is an array\n        if (ArrayBuffer.isView(prop[eid])) {\n          const type = prop[eid].constructor.name.replace('Array', '')\n          const indexType = prop[eid][$indexType]\n          const indexBytes = prop[eid][$indexBytes]\n\n          // save space for count of dirty array elements\n          const countWhere2 = where\n          where += indexBytes\n\n          let arrayWriteCount = 0\n\n          // write index,value\n          for (let i = 0; i < prop[eid].length; i++) {\n\n            if (shadow) {\n\n              const changed = shadow[eid][i] !== prop[eid][i]\n              \n              // sync shadow\n              shadow[eid][i] = prop[eid][i]              \n\n              // if state has not changed since the last call\n              // todo: if newly added then entire component will serialize (instead of only changed values)\n              if (!changed && !newlyAddedComponent) {\n                // skip writing this value\n                continue\n              }\n            }\n            \n            // write array index\n            view[`set${indexType}`](where, i)\n            where += indexBytes\n            \n            // write value at that index\n            const value = prop[eid][i]\n            view[`set${type}`](where, value)\n            where += prop[eid].BYTES_PER_ELEMENT\n            arrayWriteCount++\n          }\n\n          if (arrayWriteCount > 0) {\n            // write total element count\n            view[`set${indexType}`](countWhere2, arrayWriteCount)\n            writeCount++\n          } else {\n            where = rewindWhere\n            continue\n          }\n        } else {\n\n          if (shadow) {\n\n            const changed = shadow[eid] !== prop[eid]\n\n            shadow[eid] = prop[eid]\n\n            // do not write value if diffing and no change\n            if (!changed && !newlyAddedComponent) {\n              // rewind the serializer\n              where = rewindWhere\n              // skip writing this value\n              continue\n            }\n\n          }  \n\n\n          const type = prop.constructor.name.replace('Array', '')\n          // set value next [type] bytes\n          view[`set${type}`](where, prop[eid])\n          where += prop.BYTES_PER_ELEMENT\n\n          writeCount++\n        }\n      }\n\n      if (writeCount > 0) {\n        // write how many eid/value pairs were written\n        view.setUint32(countWhere, writeCount)\n      } else {\n        // if nothing was written (diffed with no changes) \n        // then move cursor back 5 bytes (remove PID and countWhere space)\n        where -= 5\n      }\n    }\n    return buffer.slice(0, where)\n  }\n}\n\nconst newEntities = new Map()\n\n/**\n * Defines a new deserializer which targets the given components to deserialize onto a given world.\n *\n * @param {object|array} target\n * @returns {function} deserializer\n */\nexport const defineDeserializer = (target) => {\n  const isWorld = Object.getOwnPropertySymbols(target).includes($componentMap)\n  let [componentProps] = canonicalize(target)\n\n  const deserializedEntities = new Set()\n\n  return (world, packet, mode=0) => {\n\n    newEntities.clear()\n    \n    if (resized) {\n      [componentProps] = canonicalize(target)\n      resized = false\n    }\n\n    if (isWorld) {\n      componentProps = []\n      target[$componentMap].forEach((c, component) => {\n        if (component[$storeFlattened])\n          componentProps.push(...component[$storeFlattened])\n        else componentProps.push(component)\n      })\n    }\n\n    const localEntities = world[$localEntities]\n    const localEntityLookup = world[$localEntityLookup]\n\n    const view = new DataView(packet)\n    let where = 0\n\n    while (where < packet.byteLength) {\n\n      // pid\n      const pid = view.getUint8(where)\n      where += 1\n\n      // entity count\n      const entityCount = view.getUint32(where)\n      where += 4\n\n      // component property\n      const prop = componentProps[pid]\n\n      // Get the entities and set their prop values\n      for (let i = 0; i < entityCount; i++) {\n        let eid = view.getUint32(where) // throws with [changed, c, changed]\n        where += 4\n\n        if (mode === DESERIALIZE_MODE.MAP) {\n          if (localEntities.has(eid)) {\n            eid = localEntities.get(eid)\n          } else if (newEntities.has(eid)) {\n            eid = newEntities.get(eid)\n          } else {\n            const newEid = addEntity(world)\n            localEntities.set(eid, newEid)\n            localEntityLookup.set(newEid, eid)\n            newEntities.set(eid, newEid)\n            eid = newEid\n          }\n        }\n\n        if (mode === DESERIALIZE_MODE.APPEND ||  \n          mode === DESERIALIZE_MODE.REPLACE && !world[$entitySparseSet].has(eid)\n        ) {\n          const newEid = newEntities.get(eid) || addEntity(world)\n          newEntities.set(eid, newEid)\n          eid = newEid\n        }\n\n        const component = prop[$storeBase]()\n        if (!hasComponent(world, component, eid)) {\n          addComponent(world, component, eid)\n        }\n\n        // add eid to deserialized ents after it has been transformed by MAP mode\n        deserializedEntities.add(eid)\n\n        if (component[$tagStore]) {\n          continue\n        }\n        \n        if (ArrayBuffer.isView(prop[eid])) {\n          const array = prop[eid]\n          const count = view[`get${array[$indexType]}`](where)\n          where += array[$indexBytes]\n\n          // iterate over count\n          for (let i = 0; i < count; i++) {\n            const index = view[`get${array[$indexType]}`](where)\n            where += array[$indexBytes]\n\n            const value = view[`get${array.constructor.name.replace('Array', '')}`](where)\n            where += array.BYTES_PER_ELEMENT\n            if (prop[$isEidType]) {\n              let localEid\n              if (localEntities.has(value)) {\n                localEid = localEntities.get(value)\n              } else if (newEntities.has(value)) {\n                localEid = newEntities.get(value)\n              } else {\n                const newEid = addEntity(world)\n                localEntities.set(value, newEid)\n                localEntityLookup.set(newEid, value)\n                newEntities.set(value, newEid)\n                localEid = newEid\n              }\n              prop[eid][index] = localEid\n            } else prop[eid][index] = value\n          }\n        } else {\n          const value = view[`get${prop.constructor.name.replace('Array', '')}`](where)\n          where += prop.BYTES_PER_ELEMENT\n\n          if (prop[$isEidType]) {\n            let localEid\n            if (localEntities.has(value)) {\n              localEid = localEntities.get(value)\n            } else if (newEntities.has(value)) {\n              localEid = newEntities.get(value)\n            } else {\n              const newEid = addEntity(world)\n              localEntities.set(value, newEid)\n              localEntityLookup.set(newEid, value)\n              newEntities.set(value, newEid)\n              localEid = newEid\n            }\n            prop[eid] = localEid\n          } else prop[eid] = value\n        }\n      }\n    }\n\n    const ents = Array.from(deserializedEntities)\n\n    deserializedEntities.clear()\n\n    return ents\n  }\n}","import { resizeComponents } from './Component.js'\nimport { $notQueries, $queries, queryAddEntity, queryCheckEntity, queryRemoveEntity } from './Query.js'\nimport { $localEntities, $localEntityLookup, resizeWorlds } from './World.js'\nimport { setSerializationResized } from './Serialize.js'\n\nexport const $entityMasks = Symbol('entityMasks')\nexport const $entityComponents = Symbol('entityComponents')\nexport const $entitySparseSet = Symbol('entitySparseSet')\nexport const $entityArray = Symbol('entityArray')\nexport const $entityIndices = Symbol('entityIndices')\nexport const $removedEntities = Symbol('removedEntities')\n\nlet defaultSize = 100000\n\n// need a global EID cursor which all worlds and all components know about\n// so that world entities can posess entire rows spanning all component tables\nlet globalEntityCursor = 0\nlet globalSize = defaultSize\nlet resizeThreshold = () => globalSize - (globalSize / 5)\n\nexport const getGlobalSize = () => globalSize\n\n// removed eids should also be global to prevent memory leaks\nconst removed = []\n\nexport const resetGlobals = () => {\n  globalSize = defaultSize\n  globalEntityCursor = 0\n  removed.length = 0\n}\n\nexport const getDefaultSize = () => defaultSize\n\n/**\n * Sets the default maximum number of entities for worlds and component stores.\n *\n * @param {number} newSize\n */\nexport const setDefaultSize = newSize => { \n  const oldSize = globalSize\n\n  defaultSize = newSize\n  resetGlobals()\n\n  globalSize = newSize\n  resizeWorlds(newSize)\n  resizeComponents(newSize)\n  setSerializationResized(true)\n\n  console.info(` bitECS - resizing all data stores from ${oldSize} to ${newSize}`)\n}\n\nexport const getEntityCursor = () => globalEntityCursor\nexport const getRemovedEntities = () => removed\n\nexport const eidToWorld = new Map()\n\n/**\n * Adds a new entity to the specified world.\n *\n * @param {World} world\n * @returns {number} eid\n */\nexport const addEntity = (world) => {\n\n  // if data stores are 80% full\n  if (globalEntityCursor >= resizeThreshold()) {\n    // grow by half the original size rounded up to a multiple of 4\n    const size = globalSize\n    const amount = Math.ceil((size/2) / 4) * 4\n    setDefaultSize(size + amount)\n  }\n  \n  const eid = removed.length > Math.round(defaultSize * 0.01) ? removed.shift() : globalEntityCursor++\n  \n  world[$entitySparseSet].add(eid)\n  eidToWorld.set(eid, world)\n\n  world[$notQueries].forEach(q => {\n    const match = queryCheckEntity(world, q, eid)\n    if (match) queryAddEntity(q, eid)\n  })\n\n  world[$entityComponents].set(eid, new Set())\n\n  return eid\n}\n\n/**\n * Removes an existing entity from the specified world.\n *\n * @param {World} world\n * @param {number} eid\n */\nexport const removeEntity = (world, eid) => {\n  // Check if entity is already removed\n  if (!world[$entitySparseSet].has(eid)) return\n\n  // Remove entity from all queries\n  // TODO: archetype graph\n  world[$queries].forEach(q => {\n    queryRemoveEntity(world, q, eid)\n  })\n\n  // Free the entity\n  removed.push(eid)\n\n  // remove all eid state from world\n  world[$entitySparseSet].remove(eid)\n  world[$entityComponents].delete(eid)\n\n  // remove from deserializer mapping\n  world[$localEntities].delete(world[$localEntityLookup].get(eid))\n  world[$localEntityLookup].delete(eid)\n\n  // Clear entity bitmasks\n  for (let i = 0; i < world[$entityMasks].length; i++) world[$entityMasks][i][eid] = 0\n}\n\n/**\n *  Returns an array of components that an entity possesses.\n *\n * @param {*} world\n * @param {*} eid\n */\nexport const getEntityComponents = (world, eid) => {\n  if (eid === undefined) throw new Error('bitECS - entity is undefined.')\n  if (!world[$entitySparseSet].has(eid)) throw new Error('bitECS - entity does not exist in the world.')\n  return Array.from(world[$entityComponents].get(eid))\n}\n\n/**\n * Checks the existence of an entity in a world\n * \n * @param {World} world \n * @param {number} eid \n */\nexport const entityExists = (world, eid) => world[$entitySparseSet].has(eid)","import { SparseSet } from './Util.js'\nimport { $queryShadow, $storeFlattened, $tagStore, createShadow } from './Storage.js'\nimport { $componentMap, registerComponent } from './Component.js'\nimport { $entityMasks, $entityArray, getEntityCursor, $entitySparseSet } from './Entity.js'\n\n\n\nexport function Not(c) { return () => [c, 'not'] }\nexport function Or(c) { return () => [c, 'or'] }\nexport function Changed(c) { return () => [c, 'changed'] }\n\nexport function Any(...comps) { return function QueryAny() { return comps } }\nexport function All(...comps) { return function QueryAll() { return comps } }\nexport function None(...comps) { return function QueryNone() { return comps } }\n\nexport const $queries = Symbol('queries')\nexport const $notQueries = Symbol('notQueries')\n\nexport const $queryAny = Symbol('queryAny')\nexport const $queryAll = Symbol('queryAll')\nexport const $queryNone = Symbol('queryNone')\n\nexport const $queryMap = Symbol('queryMap')\nexport const $dirtyQueries = Symbol('$dirtyQueries')\nexport const $queryComponents = Symbol('queryComponents')\nexport const $enterQuery = Symbol('enterQuery')\nexport const $exitQuery = Symbol('exitQuery')\n\n/**\n * Given an existing query, returns a new function which returns entities who have been added to the given query since the last call of the function.\n *\n * @param {function} query\n * @returns {function} enteredQuery\n */\nexport const enterQuery = query => world => {\n  if (!world[$queryMap].has(query)) registerQuery(world, query)\n  const q = world[$queryMap].get(query)\n  // queryCommitRemovals(q)\n  const entered = q.entered.dense.slice()\n  q.entered = SparseSet()\n  return entered\n}\n\n/**\n * Given an existing query, returns a new function which returns entities who have been removed from the given query since the last call of the function.\n *\n * @param {function} query\n * @returns {function} enteredQuery\n */\nexport const exitQuery = query => world => {\n  if (!world[$queryMap].has(query)) registerQuery(world, query)\n  const q = world[$queryMap].get(query)\n  // queryCommitRemovals(q)\n  const exited = q.exited.dense.slice()\n  q.exited = SparseSet()\n  return exited\n}\n\nexport const registerQuery = (world, query) => {\n\n  const components = []\n  const notComponents = []\n  const changedComponents = []\n\n  query[$queryComponents].forEach(c => {\n    if (typeof c === 'function') {\n      const [comp, mod] = c()\n      if (!world[$componentMap].has(comp)) registerComponent(world, comp)\n      if (mod === 'not') {\n        notComponents.push(comp)\n      }\n      if (mod === 'changed') {\n        changedComponents.push(comp)\n        components.push(comp)\n      }\n      // if (mod === 'all') {\n      //   allComponents.push(comp)\n      // }\n      // if (mod === 'any') {\n      //   anyComponents.push(comp)\n      // }\n      // if (mod === 'none') {\n      //   noneComponents.push(comp)\n      // }\n    } else {\n      if (!world[$componentMap].has(c)) registerComponent(world, c)\n      components.push(c)\n    }\n  })\n\n\n  const mapComponents = c => world[$componentMap].get(c)\n\n  const allComponents = components.concat(notComponents).map(mapComponents)\n\n  // const sparseSet = Uint32SparseSet(getGlobalSize())\n  const sparseSet = SparseSet()\n\n  const archetypes = []\n  // const changed = SparseSet()\n  const changed = []\n  const toRemove = SparseSet()\n  const entered = SparseSet()\n  const exited = SparseSet()\n\n  const generations = allComponents\n    .map(c => c.generationId)\n    .reduce((a,v) => {\n      if (a.includes(v)) return a\n      a.push(v)\n      return a\n    }, [])\n\n  const reduceBitflags = (a,c) => {\n    if (!a[c.generationId]) a[c.generationId] = 0\n    a[c.generationId] |= c.bitflag\n    return a\n  }\n  const masks = components\n    .map(mapComponents)\n    .reduce(reduceBitflags, {})\n\n  const notMasks = notComponents\n    .map(mapComponents)\n    .reduce(reduceBitflags, {})\n\n  // const orMasks = orComponents\n  //   .map(mapComponents)\n  //   .reduce(reduceBitmasks, {})\n\n  const hasMasks = allComponents\n    .reduce(reduceBitflags, {})\n\n  const flatProps = components\n    .filter(c => !c[$tagStore])\n    .map(c => Object.getOwnPropertySymbols(c).includes($storeFlattened) ? c[$storeFlattened] : [c])\n    .reduce((a,v) => a.concat(v), [])\n\n  const shadows = []\n\n  const q = Object.assign(sparseSet, {\n    archetypes,\n    changed,\n    components,\n    notComponents,\n    changedComponents,\n    allComponents,\n    masks,\n    notMasks,\n    // orMasks,\n    hasMasks,\n    generations,\n    flatProps,\n    toRemove,\n    entered,\n    exited,\n    shadows,\n  })\n\n  world[$queryMap].set(query, q)\n  world[$queries].add(q)\n  \n  allComponents.forEach(c => {\n    c.queries.add(q)\n  })\n\n  if (notComponents.length) world[$notQueries].add(q)\n\n  for (let eid = 0; eid < getEntityCursor(); eid++) {\n    if (!world[$entitySparseSet].has(eid)) continue\n    const match = queryCheckEntity(world, q, eid)\n    if (match) queryAddEntity(q, eid)\n  }\n}\n\nconst generateShadow = (q, pid) => {\n  const $ = Symbol()\n  const prop = q.flatProps[pid]\n  createShadow(prop, $)\n  q.shadows[pid] = prop[$]\n  return prop[$]\n}\n\nconst diff = (q, clearDiff) => {\n  if (clearDiff) q.changed = []\n  const { flatProps, shadows } = q\n  for (let i = 0; i < q.dense.length; i++) {\n    const eid = q.dense[i]\n    let dirty = false\n    for (let pid = 0; pid < flatProps.length; pid++) {\n      const prop = flatProps[pid]\n      const shadow = shadows[pid] || generateShadow(q, pid)\n      if (ArrayBuffer.isView(prop[eid])) {\n        for (let i = 0; i < prop[eid].length; i++) {\n          if (prop[eid][i] !== shadow[eid][i]) {\n            dirty = true\n            break\n          }\n        }\n        shadow[eid].set(prop[eid])\n      } else {\n        if (prop[eid] !== shadow[eid]) {\n          dirty = true\n          shadow[eid] = prop[eid]\n        }\n      }\n    }\n    if (dirty) q.changed.push(eid)\n  }\n  return q.changed\n}\n\n// const queryEntityChanged = (q, eid) => {\n//   if (q.changed.has(eid)) return\n//   q.changed.add(eid)\n// }\n\n// export const entityChanged = (world, component, eid) => {\n//   const { changedQueries } = world[$componentMap].get(component)\n//   changedQueries.forEach(q => {\n//     const match = queryCheckEntity(world, q, eid)\n//     if (match) queryEntityChanged(q, eid)\n//   })\n// }\n\nconst flatten = (a,v) => a.concat(v)\n\nconst aggregateComponentsFor = mod => x => x.filter(f => f.name === mod().constructor.name).reduce(flatten)\n\nconst getAnyComponents = aggregateComponentsFor(Any)\nconst getAllComponents = aggregateComponentsFor(All)\nconst getNoneComponents = aggregateComponentsFor(None)\n\n/**\n * Defines a query function which returns a matching set of entities when called on a world.\n *\n * @param {array} components\n * @returns {function} query\n */\n\nexport const defineQuery = (...args) => {\n  let components\n  let any, all, none\n  if (Array.isArray(args[0])) {\n    components = args[0]\n  } else {\n    // any = getAnyComponents(args)\n    // all = getAllComponents(args)\n    // none = getNoneComponents(args)\n  }\n  \n\n  if (components === undefined || components[$componentMap] !== undefined) {\n    return world => world ? world[$entityArray] : components[$entityArray]\n  }\n\n  const query = function (world, clearDiff=true) {\n    if (!world[$queryMap].has(query)) registerQuery(world, query)\n\n    const q = world[$queryMap].get(query)\n\n    commitRemovals(world)\n\n    if (q.changedComponents.length) return diff(q, clearDiff)\n    // if (q.changedComponents.length) return q.changed.dense\n\n    return q.dense\n  }\n\n  query[$queryComponents] = components\n  query[$queryAny] = any\n  query[$queryAll] = all\n  query[$queryNone] = none\n\n  return query\n}\n\nconst bin = value => {\n  if (!Number.isSafeInteger(value)) {\n    throw new TypeError('value must be a safe integer');\n  }\n\n  const negative = value < 0;\n  const twosComplement = negative ? Number.MAX_SAFE_INTEGER + value + 1 : value;\n  const signExtend = negative ? '1' : '0';\n\n  return twosComplement.toString(2).padStart(4, '0').padStart(0, signExtend);\n}\n\n// TODO: archetype graph\nexport const queryCheckEntity = (world, q, eid) => {\n  const { masks, notMasks, generations } = q\n  let or = 0\n  for (let i = 0; i < generations.length; i++) {\n    const generationId = generations[i]\n    const qMask = masks[generationId]\n    const qNotMask = notMasks[generationId]\n    // const qOrMask = orMasks[generationId]\n    const eMask = world[$entityMasks][generationId][eid]\n    \n    // any\n    // if (qOrMask && (eMask & qOrMask) !== qOrMask) {\n    //   continue\n    // }\n    // not all \n    // if (qNotMask && (eMask & qNotMask) === qNotMask) {\n    // }\n    // not any\n    if (qNotMask && (eMask & qNotMask) !== 0) {\n      return false\n    }\n    // all\n    if (qMask && (eMask & qMask) !== qMask) {\n      return false\n    }\n  }\n  return true\n}\n\nexport const queryCheckComponent = (q, c) => {\n  const { generationId, bitflag } = c\n  const { hasMasks } = q\n  const mask = hasMasks[generationId]\n  return (mask & bitflag) === bitflag\n}\n\nexport const queryAddEntity = (q, eid) => {\n  q.toRemove.remove(eid)\n  // if (!q.has(eid)) \n  q.entered.add(eid)\n  q.add(eid)\n}\n\nconst queryCommitRemovals = (q) => {\n  for (let i = q.toRemove.dense.length-1; i >= 0; i--) {\n    const eid = q.toRemove.dense[i]\n    q.toRemove.remove(eid)\n    q.remove(eid)\n  }\n}\n\nexport const commitRemovals = (world) => {\n  if (!world[$dirtyQueries].size) return\n  world[$dirtyQueries].forEach(queryCommitRemovals)\n  world[$dirtyQueries].clear()\n}\n\nexport const queryRemoveEntity = (world, q, eid) => {\n  if (!q.has(eid) || q.toRemove.has(eid)) return\n  q.toRemove.add(eid)\n  world[$dirtyQueries].add(q)\n  q.exited.add(eid)\n}\n\n\n/**\n * Resets a Changed-based query, clearing the underlying list of changed entities.\n *\n * @param {World} world\n * @param {function} query\n */\nexport const resetChangedQuery = (world, query) => {\n  const q = world[$queryMap].get(query)\n  q.changed = []\n}\n\n/**\n * Removes a query from a world.\n *\n * @param {World} world\n * @param {function} query\n */\nexport const removeQuery = (world, query) => {\n  const q = world[$queryMap].get(query)\n  world[$queries].delete(q)\n  world[$queryMap].delete(query)\n}","import { $storeSize, createStore, resetStoreFor, resizeStore } from './Storage.js'\nimport { $queries, queryAddEntity, queryRemoveEntity, queryCheckEntity, commitRemovals } from './Query.js'\nimport { $bitflag, $size } from './World.js'\nimport { $entityMasks, getDefaultSize, eidToWorld, $entityComponents, getGlobalSize, $entitySparseSet } from './Entity.js'\n\nexport const $componentMap = Symbol('componentMap')\n\nexport const components = []\n\nexport const resizeComponents = (size) => {\n  components.forEach(component => resizeStore(component, size))\n}\n\n\n/**\n * Defines a new component store.\n *\n * @param {object} schema\n * @returns {object}\n */\nexport const defineComponent = (schema, size) => {\n  const component = createStore(schema, size || getGlobalSize())\n  if (schema && Object.keys(schema).length) components.push(component)\n  return component\n}\n\nexport const incrementBitflag = (world) => {\n  world[$bitflag] *= 2\n  if (world[$bitflag] >= 2**31) {\n    world[$bitflag] = 1\n    world[$entityMasks].push(new Uint32Array(world[$size]))\n  }\n}\n\n\n/**\n * Registers a component with a world.\n *\n * @param {World} world\n * @param {Component} component\n */\nexport const registerComponent = (world, component) => {\n  if (!component) throw new Error(`bitECS - Cannot register null or undefined component`)\n\n  const queries = new Set()\n  const notQueries = new Set()\n  const changedQueries = new Set()\n\n  world[$queries].forEach(q => {\n    if (q.allComponents.includes(component)) {\n      queries.add(q)\n    }\n  })\n\n  world[$componentMap].set(component, { \n    generationId: world[$entityMasks].length - 1,\n    bitflag: world[$bitflag],\n    store: component,\n    queries,\n    notQueries,\n    changedQueries,\n  })\n\n  if (component[$storeSize] < getGlobalSize()) {\n    resizeStore(component, getGlobalSize())\n  }\n\n  incrementBitflag(world)\n}\n\n/**\n * Registers multiple components with a world.\n *\n * @param {World} world\n * @param {Component} components\n */\nexport const registerComponents = (world, components) => {\n  components.forEach(c => registerComponent(world, c))\n}\n\n/**\n * Checks if an entity has a component.\n *\n * @param {World} world\n * @param {Component} component\n * @param {number} eid\n * @returns {boolean}\n */\nexport const hasComponent = (world, component, eid) => {\n  const registeredComponent = world[$componentMap].get(component)\n  if (!registeredComponent) return false\n  const { generationId, bitflag } = registeredComponent\n  const mask = world[$entityMasks][generationId][eid]\n  return (mask & bitflag) === bitflag\n}\n\n/**\n * Adds a component to an entity\n *\n * @param {World} world\n * @param {Component} component\n * @param {number} eid\n * @param {boolean} [reset=false]\n */\nexport const addComponent = (world, component, eid, reset=false) => {\n  if (eid === undefined) throw new Error('bitECS - entity is undefined.')\n  if (!world[$entitySparseSet].has(eid)) throw new Error('bitECS - entity does not exist in the world.')\n  if (!world[$componentMap].has(component)) registerComponent(world, component)\n  if (hasComponent(world, component, eid)) return\n\n  const c = world[$componentMap].get(component)\n  const { generationId, bitflag, queries, notQueries } = c\n    \n  // Add bitflag to entity bitmask\n  world[$entityMasks][generationId][eid] |= bitflag\n\n  // todo: archetype graph\n  queries.forEach(q => {\n    // remove this entity from toRemove if it exists in this query\n    if (q.toRemove.has(eid)) q.toRemove.remove(eid)\n    const match = queryCheckEntity(world, q, eid)\n    if (match) queryAddEntity(q, eid)\n    if (!match) queryRemoveEntity(world, q, eid)\n  })\n\n  world[$entityComponents].get(eid).add(component)\n\n  // Zero out each property value\n  if (reset) resetStoreFor(component, eid)\n}\n\n/**\n * Removes a component from an entity and resets component state unless otherwise specified.\n *\n * @param {World} world\n * @param {Component} component\n * @param {number} eid\n * @param {boolean} [reset=true]\n */\nexport const removeComponent = (world, component, eid, reset=true) => {\n  if (eid === undefined) throw new Error('bitECS - entity is undefined.')\n  if (!world[$entitySparseSet].has(eid)) throw new Error('bitECS - entity does not exist in the world.')\n  if (!hasComponent(world, component, eid)) return\n\n  const c = world[$componentMap].get(component)\n  const { generationId, bitflag, queries } = c\n\n  // Remove flag from entity bitmask\n  world[$entityMasks][generationId][eid] &= ~bitflag\n  \n  // todo: archetype graph\n  queries.forEach(q => {\n    // remove this entity from toRemove if it exists in this query\n    if (q.toRemove.has(eid)) q.toRemove.remove(eid)\n    const match = queryCheckEntity(world, q, eid)\n    if (match) queryAddEntity(q, eid)\n    if (!match) queryRemoveEntity(world, q, eid)\n  })\n\n  world[$entityComponents].get(eid).delete(component)\n\n  // Zero out each property value\n  if (reset) resetStoreFor(component, eid)\n}\n","import { $componentMap } from './Component.js'\nimport { $queryMap, $queries, $dirtyQueries, $notQueries } from './Query.js'\nimport { $entityArray, $entityComponents, $entityMasks, $entitySparseSet, getGlobalSize, removeEntity } from './Entity.js'\nimport { resize } from './Storage.js'\nimport { SparseSet } from './Util.js'\n\nexport const $size = Symbol('size')\nexport const $resizeThreshold = Symbol('resizeThreshold')\nexport const $bitflag = Symbol('bitflag')\nexport const $archetypes = Symbol('archetypes')\nexport const $localEntities = Symbol('localEntities')\nexport const $localEntityLookup = Symbol('localEntityLookp')\n\nexport const worlds = []\n\nexport const resizeWorlds = (size) => {\n  worlds.forEach(world => {\n    world[$size] = size\n\n    for (let i = 0; i < world[$entityMasks].length; i++) {\n      const masks = world[$entityMasks][i];\n      world[$entityMasks][i] = resize(masks, size)\n    }\n    \n    world[$resizeThreshold] = world[$size] - (world[$size] / 5)\n  })\n}\n\n/**\n * Creates a new world.\n *\n * @returns {object}\n */\nexport const createWorld = (...args) => {\n  const world = typeof args[0] === 'object'\n    ? args[0]\n    : {}\n  const size = typeof args[0] === 'number' \n    ? args[0] \n    : typeof args[1] === 'number' \n      ? args[1] \n      : getGlobalSize()\n  resetWorld(world, size)\n  worlds.push(world)\n  return world\n}\n\n/**\n * Resets a world.\n *\n * @param {World} world\n * @returns {object}\n */\nexport const resetWorld = (world, size = getGlobalSize()) => {\n  world[$size] = size\n\n  if (world[$entityArray]) world[$entityArray].forEach(eid => removeEntity(world, eid))\n\n  world[$entityMasks] = [new Uint32Array(size)]\n  world[$entityComponents] = new Map()\n  world[$archetypes] = []\n\n  world[$entitySparseSet] = SparseSet()\n  world[$entityArray] = world[$entitySparseSet].dense\n\n  world[$bitflag] = 1\n\n  world[$componentMap] = new Map()\n\n  world[$queryMap] = new Map()\n  world[$queries] = new Set()\n  world[$notQueries] = new Set()\n  world[$dirtyQueries] = new Set()\n\n  world[$localEntities] = new Map()\n  world[$localEntityLookup] = new Map()\n\n  return world\n}\n\n/**\n * Deletes a world.\n *\n * @param {World} world\n */\nexport const deleteWorld = (world) => {\n  Object.getOwnPropertySymbols(world).forEach($ => { delete world[$] })\n  Object.keys(world).forEach(key => { delete world[key] })\n  worlds.splice(worlds.indexOf(world), 1)\n}\n\n/**\n * Returns all components registered to a world\n * \n * @param {World} world \n * @returns Array\n */\nexport const getWorldComponents = (world) => Array.from(world[$componentMap].keys())\n\n/**\n * Returns all existing entities in a world\n * \n * @param {World} world \n * @returns Array\n */\nexport const getAllEntities = (world) => world[$entitySparseSet].dense.slice(0)","import { createWorld, resetWorld, deleteWorld, getWorldComponents } from './World.js'\nimport { addEntity, removeEntity, setDefaultSize, getEntityComponents, entityExists } from './Entity.js'\nimport { defineComponent, registerComponent, registerComponents, hasComponent, addComponent, removeComponent } from './Component.js'\nimport { defineSystem } from './System.js'\nimport { defineQuery, enterQuery, exitQuery, Changed, Not, commitRemovals, resetChangedQuery, removeQuery } from './Query.js'\nimport { defineSerializer, defineDeserializer, DESERIALIZE_MODE } from './Serialize.js'\nimport { parentArray } from './Storage.js'\nimport { TYPES_ENUM } from './Constants.js'\n\nexport const pipe = (...fns) => (input) => {\n  let tmp = input\n  for (let i = 0; i < fns.length; i++) {\n    const fn = fns[i]\n    tmp = fn(tmp)\n  }\n  return tmp\n}\n\nexport const Types = TYPES_ENUM\n\nexport {\n\n  setDefaultSize,\n  createWorld,\n  resetWorld,\n  deleteWorld,\n  addEntity,\n  removeEntity,\n  entityExists,\n  getWorldComponents,\n  \n  registerComponent,\n  registerComponents,\n  defineComponent,\n  addComponent,\n  removeComponent,\n  hasComponent,\n  getEntityComponents,\n\n  defineQuery,\n  Changed,\n  Not,\n  enterQuery,\n  exitQuery,\n  commitRemovals,\n  resetChangedQuery,\n  removeQuery,\n\n  defineSystem,\n  \n  defineSerializer,\n  defineDeserializer,\n  DESERIALIZE_MODE,\n\n  parentArray,\n\n}\n","import { addComponent, addEntity, Component } from 'bitecs';\nimport { EventEmitter } from 'eventemitter3';\nimport World from './world';\n\nexport default class Entity extends EventEmitter {\n\tworld: World;\n\teid: number;\n\n\t// Position\n\tget x()    { return this.world.components.position.x[this.eid]; }\n\tset x(val) { this.world.components.position.x[this.eid] = val; }\n\tget y()    { return this.world.components.position.y[this.eid]; }\n\tset y(val) { this.world.components.position.y[this.eid] = val; }\n\tget width()    { return this.world.components.position.width[this.eid]; }\n\tset width(val) { this.world.components.position.width[this.eid] = val; }\n\tget height()    { return this.world.components.position.height[this.eid]; }\n\tset height(val) { this.world.components.position.height[this.eid] = val; }\n\n\t// Health\n\tget shields()    { return this.world.components.health.shields[this.eid]; }\n\tset shields(val) { this.world.components.health.shields[this.eid] = val; }\n\tget maxShields()    { return this.world.components.health.maxShields[this.eid]; }\n\tset maxShields(val) { this.world.components.health.maxShields[this.eid] = val; }\n\tget timeToRegenerateShields()    { return this.world.components.health.timeToRegenerateShields[this.eid]; }\n\tset timeToRegenerateShields(val) { this.world.components.health.timeToRegenerateShields[this.eid] = val; }\n\tget timeSinceShieldRegeneration()    { return this.world.components.health.timeSinceShieldRegeneration[this.eid]; }\n\tset timeSinceShieldRegeneration(val) { this.world.components.health.timeSinceShieldRegeneration[this.eid] = val; }\n\tget timeSinceTakenDamage()    { return this.world.components.health.timeSinceTakenDamage[this.eid]; }\n\tset timeSinceTakenDamage(val) { this.world.components.health.timeSinceTakenDamage[this.eid] = val; }\n\tget dead()    { return this.world.components.health.shields[this.eid]; }\n\tset dead(val) { this.world.components.health.shields[this.eid] = val; }\n\n\ttype = 'entity';\n\tkey = 'boid';\n\n\tconstructor(world: World) {\n\t\tsuper();\n\t\tthis.eid = addEntity(world.ecs);\n\t\tthis.world = world;\n\n\t\tthis.addComponent(world.components.position);\n\t\tthis.addComponent(world.components.health);\n\n\t\tthis.shields = 1;\n\t\tthis.maxShields = 1;\n\t\tthis.timeToRegenerateShields = 1;\n\t\tthis.timeSinceShieldRegeneration = 0;\n\t\tthis.timeSinceTakenDamage = 0;\n\t\tthis.dead = 0;\n\t}\n\n\tload(config: any) {\n\t\t// TODO: Need a way which does not rely on manually setup get/set.  Maybe in our own system define how it is serialized as part of the component registration?\n\t\tObject.keys(config).forEach((key: string) => {\n\t\t\t// @ts-expect-error\n\t\t\tthis[key] = config[key];\n\t\t});\n\t}\n\n\tset(component: 'string', name: 'string', value: any) {\n\t\t// @ts-expect-error\n\t\tthis.world.components[component][name][this.eid] = value;\n\t}\n\n\tprotected addComponent(component: Component) {\n\t\taddComponent(this.world.ecs, component, this.eid);\n\t}\n}","import Entity from './entity';\nimport World from './world';\n\nexport default class Station extends Entity {\n\tget color()    { return this.world.components.controller.color[this.eid]; }\n\tset color(val) { this.world.components.controller.color[this.eid] = val; }\n\tget money()    { return this.world.components.controller.money[this.eid]; }\n\tset money(val) { this.world.components.controller.money[this.eid] = val; }\n\n\tconstructor(world: World) {\n\t\tsuper(world);\n\t\tthis.addComponent(world.components.controller);\n\n\t\tthis.key = 'station';\n\t\tthis.width = 20;\n\t\tthis.height = 20;\n\t\tthis.shields = 2;\n\t\tthis.maxShields = 2;\n\t\tthis.timeToRegenerateShields = 5;\n\t}\n}","import Entity from './entity';\nimport Station from './station';\n\nexport default class Ship extends Entity {\n\tget color()    { return this.world.components.controller.color[this.world.components.controlled.owner[this.eid]]; }\n\n\tget velocityX()    { return this.world.components.velocity.x[this.eid]; }\n\tset velocityX(val) { this.world.components.velocity.x[this.eid] = val; }\n\tget velocityY()    { return this.world.components.velocity.y[this.eid]; }\n\tset velocityY(val) { this.world.components.velocity.y[this.eid] = val; }\n\n\tget station() { return this.world.getEntity(this.eid); }\n\n\tconstructor(station: Station) {\n\t\tsuper(station.world);\n\n\t\tlet world = station.world;\n\t\tthis.addComponent(world.components.velocity);\n\t\tthis.addComponent(world.components.controlled);\n\t\tthis.addComponent(world.components.attack);\n\t\t\n\t\tthis.width = 10;\n\t\tthis.height = 5;\n\t\tthis.shields = 1;\n\t\tthis.maxShields = 1;\n\t\tthis.timeToRegenerateShields = 1;\n\t\tthis.world.components.velocity.speed[this.eid] = 100;\n\t\tworld.components.controlled.owner[this.eid] = station.eid;\n\t}\n}","import computeAngle from '@/math/compute-angle';\nimport { defineQuery, IWorld } from 'bitecs';\nimport Ship from '../entities/ship';\nimport Station from '../entities/station';\nimport World from '../entities/world';\n\nexport default function spawnShipSystem(world: World) {\n\tconst controller = world.components.controller;\n\tconst health = world.components.health;\n\tlet stationQuery = defineQuery([controller]);\n\n\treturn (ecs: IWorld) => {\n\t\t// TODO: Remove dependency on our containers so this could realistically be running in a simple worker with just duplicated data\n\t\tlet stations = stationQuery(ecs).filter(eid => !health.dead[eid]);\n\t\tstations.forEach(stationEid => {\n\t\t\tlet station = world.getEntity(stationEid) as Station;\n\t\t\tif(controller.money[stationEid] > 0) {\n\t\t\t\tlet ship = new Ship(station);\n\t\t\t\tship.x = station.x;\n\t\t\t\tship.y = station.y;\n\t\t\t\tship.velocityX = (Math.random() > 0.5 ? -1 : 1) * Math.random() * world.components.velocity.speed[ship.eid];\n\t\t\t\tship.velocityY = (Math.random() > 0.5 ? -1 : 1) * Math.random() * world.components.velocity.speed[ship.eid];\n\t\t\t\tworld.components.position.angle[ship.eid] = computeAngle(ship.velocityX, ship.velocityY);\n\n\t\t\t\tworld.addEntity(ship);\n\t\t\t\tcontroller.money[stationEid]--;\n\t\t\t}\n\t\t});\n\n\t\treturn ecs;\n\t};\n}","import { Types } from 'bitecs';\n\nexport default {\n\tx: Types.f32,\n\ty: Types.f32,\n\twidth: Types.f32,\n\theight: Types.f32,\n\tangle: Types.f32\n};","import { Types } from 'bitecs';\n\nexport default {\n\tcolor: Types.f32,\n\tmoney: Types.i32\n};","import { Types } from 'bitecs';\n\nexport default {\n\tx: Types.f32,\n\ty: Types.f32,\n\tspeed: Types.f32\n};","import { Types } from 'bitecs';\n\nexport default {\n\tshields: Types.i32,\n\tmaxShields: Types.i32,\n\ttimeToRegenerateShields: Types.f32,\n\ttimeSinceShieldRegeneration: Types.f32,\n\ttimeSinceTakenDamage: Types.f32,\n\tdead: Types.ui8\n};","import { Types } from 'bitecs';\n\nexport default {\n\towner: Types.eid\n};","import { Types } from 'bitecs';\n\nexport default {\n\ttarget: Types.eid\n};","import {\n\tdefineComponent\n} from 'bitecs';\nimport position from './position';\nimport controller from './controller';\nimport velocity from './velocity';\nimport health from './health';\nimport controlled from './controlled';\nimport attack from './attack';\n\nexport default {\n\tposition: defineComponent(position),\n\tcontroller: defineComponent(controller),\n\tvelocity: defineComponent(velocity),\n\thealth: defineComponent(health),\n\tcontrolled: defineComponent(controlled),\n\tattack: defineComponent(attack)\n};","import computeAngle from '@/math/compute-angle';\nimport { defineQuery, IWorld } from 'bitecs';\nimport World from '../entities/world';\n\nexport default function velocitySystem(world: World) {\n\tconst position = world.components.position;\n\tconst velocity = world.components.velocity;\n\tlet shipQuery = defineQuery([position, velocity]);\n\n\treturn (ecs: IWorld, delta: number) => {\n\t\tlet ships = shipQuery(ecs);\n\t\tships.forEach(shipEid => {\n\t\t\tposition.x[shipEid] += velocity.x[shipEid] * delta;\n\t\t\tposition.y[shipEid] += velocity.y[shipEid] * delta;\n\n\t\t\t// TODO: Don't reference proxy world directly\n\t\t\tif(position.x[shipEid] < 0 || position.x[shipEid] > world.bounds.width) {\n\t\t\t\tvelocity.x[shipEid] = -velocity.x[shipEid];\n\t\t\t\tposition.angle[shipEid] = computeAngle(velocity.x[shipEid], velocity.y[shipEid]);\n\t\t\t}\n\t\n\t\t\tif(position.y[shipEid] < 0 || position.y[shipEid] > world.bounds.height) {\n\t\t\t\tvelocity.y[shipEid] = -velocity.y[shipEid];\n\t\t\t\tposition.angle[shipEid] = computeAngle(velocity.x[shipEid], velocity.y[shipEid]);\n\t\t\t}\n\t\t});\n\n\t\treturn ecs;\n\t};\n}","import { defineQuery, hasComponent, IWorld } from 'bitecs';\nimport World from '../entities/world';\nimport { Rectangle } from '@timohausmann/quadtree-ts/src/index.esm';\nimport distance from '@/math/distance';\nimport computeAngle from '@/math/compute-angle';\n\nexport default function collisionSystem(world: World) {\n\tconst position = world.components.position;\n\tconst velocity = world.components.velocity;\n\tconst controlled = world.components.controlled;\n\tconst controller = world.components.controller;\n\tconst health = world.components.health;\n\tlet movingQuery = defineQuery([velocity]);\n\n\t// 60fps = 0.016 so 30fps is roughly 0.032 so basically every other frame\n\tconst TIME_BETWEEN_TICKS = 0.03;\n\tlet timeSinceLastTick = TIME_BETWEEN_TICKS + 1;\n\tlet ships: Array<number> = [];\n\tlet minCountToUpdate = 0;\n\treturn (ecs: IWorld, delta: number) => {\n\t\ttimeSinceLastTick += delta;\n\t\tif(timeSinceLastTick > TIME_BETWEEN_TICKS && ships.length === 0) {\n\t\t\tships = movingQuery(ecs).filter(eid => !health.dead[eid]);\n\t\t\tminCountToUpdate = ships.length / 2;\n\t\t\ttimeSinceLastTick = 0;\n\t\t}\n\n\t\t// @ts-expect-error\n\t\tlet quadtree = ecs.quadtree;\n\t\tlet start = performance.now();\n\n\t\t// Use quadtree to see who we are colliding with\n\t\tfor(let i = 0; i < ships.length; i++) {\n\t\t\tlet eid = ships[i];\n\t\t\tlet entitiesInRange = quadtree.retrieve(new Rectangle({\n\t\t\t\tx: position.x[eid],\n\t\t\t\ty: position.y[eid],\n\t\t\t\twidth: position.width[eid],\n\t\t\t\theight: position.height[eid]\n\t\t\t})).map((result: any) => result.data.eid).filter((otherEid: number) => otherEid !== eid);\n\t\t\tlet shipColor = controller.color[controlled.owner[eid]];\n\t\t\tlet enemiesInRange = entitiesInRange.filter((otherEid: number) => {\n\t\t\t\t// Ship\n\t\t\t\tif(hasComponent(ecs, controlled, otherEid)) {\n\t\t\t\t\tlet stationEid = controlled.owner[otherEid];\n\t\t\t\t\treturn controller.color[stationEid] !== shipColor;\n\t\t\t\t}\n\t\t\t\t// Station\n\t\t\t\telse if(hasComponent(ecs, controller, otherEid)) {\n\t\t\t\t\treturn controller.color[otherEid] !== shipColor;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t\tlet collisions = enemiesInRange.filter((otherEid: number) => distance(position.x[otherEid], position.y[otherEid], position.x[eid], position.y[eid]) < Math.max(position.width[eid], position.width[otherEid]));\n\t\t\tif(collisions.length) {\n\t\t\t\tcollide(world, ships, eid, collisions[0]);\n\n\t\t\t\tvelocity.x[eid] = -velocity.x[eid];\n\t\t\t\tvelocity.y[eid] = -velocity.y[eid];\n\t\t\t\tposition.angle[eid] = computeAngle(velocity.x[eid], velocity.y[eid]);\n\t\t\t}\n\n\t\t\tif(i % 10 === 0 && i > minCountToUpdate) {\n\t\t\t\tif(performance.now() - start > (delta * 1_000 / 2)) {\n\t\t\t\t\tships = ships.slice(i);\n\t\t\t\t\treturn ecs;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tships = [];\n\t\treturn ecs;\n\t};\n}\n\nfunction collide(world: World, ships: Array<number>, eid: number, target: number) {\n\tif(!canTakeDamage(world, eid) || !canTakeDamage(world, target)) {\n\t\treturn;\n\t}\n\n\tlet enemyWorth = 1;\n\tif(hasComponent(world.ecs, world.components.controller, target)) {\n\t\tenemyWorth = ships.filter(eid => world.components.controlled.owner[eid] === target).length;\n\t}\n\n\ttakeDamage(world, ships, eid, 1);\n\ttakeDamage(world, ships, target, 1);\n\n\tconst controlled = world.components.controlled;\n\tif(world.components.health.dead[target]) {\n\t\tlet stationEid = controlled.owner[eid];\n\t\tworld.components.controller.money[stationEid] += enemyWorth;\n\t}\n\tif(world.components.health.dead[eid]) {\n\t\t// Ship\n\t\tif(hasComponent(world.ecs, controlled, target)) {\n\t\t\tlet stationEid = controlled.owner[target];\n\t\t\tworld.components.controller.money[stationEid] += 1;\n\t\t}\n\t\t// Station\n\t\telse if(hasComponent(world.ecs, world.components.controller, target)) {\n\t\t\tworld.components.controller.money[target] += 1;\n\t\t}\n\t}\n}\nfunction takeDamage(world: World, ships: Array<number>, eid: number, damage: number) {\n\tconst health = world.components.health;\n\thealth.shields[eid] -= damage;\n\thealth.timeSinceTakenDamage[eid] = 0;\n\tif(health.shields[eid] < 0) {\n\t\thealth.dead[eid] = 1;\n\n\t\t// TODO: Removing makes it so our change query doesn't detect that these are gone\n\t\t// world.removeEntity(eid);\n\t\tif(hasComponent(world.ecs, world.components.controller, eid)) {\n\t\t\tlet controlledShips = ships.filter(shipEid => world.components.controlled.owner[shipEid] === eid);\n\t\t\tcontrolledShips.forEach(shipEid => {\n\t\t\t\thealth.dead[shipEid] = 1;\n\t\t\t});\n\t\t}\n\t}\n}\n\nfunction canTakeDamage(world: World, eid: number) {\n\treturn world.components.health.timeSinceTakenDamage[eid] >= 0.2;\n}","import { defineQuery, hasComponent, IWorld } from 'bitecs';\nimport World from '../entities/world';\nimport { Rectangle } from '@timohausmann/quadtree-ts/src/index.esm';\nimport euclideanDistance from '@/math/euclidean-distance';\n\nexport default function targetEnemySystem(world: World) {\n\tconst position = world.components.position;\n\tconst velocity = world.components.velocity;\n\tconst controlled = world.components.controlled;\n\tconst controller = world.components.controller;\n\tconst health = world.components.health;\n\tconst attack = world.components.attack;\n\tlet movingQuery = defineQuery([velocity, attack]);\n\tlet controllerQuery = defineQuery([controller]);\n\n\tconst TIME_BETWEEN_TICKS = 0.2;\n\tlet timeSinceLastTick = TIME_BETWEEN_TICKS + 1;\n\tlet movingEntities: Array<number> = [];\n\tlet minCountToUpdate = 0;\n\treturn (ecs: IWorld, delta: number) => {\n\t\t// Run through all of entities eventually, but don't have more than half a frame's time to do a block of them\n\t\ttimeSinceLastTick += delta;\n\t\tif(timeSinceLastTick > TIME_BETWEEN_TICKS && movingEntities.length === 0) {\n\t\t\tmovingEntities = movingQuery(ecs).filter(eid => !health.dead[eid]);\n\t\t\tminCountToUpdate = movingEntities.length / (TIME_BETWEEN_TICKS / delta);\n\t\t\ttimeSinceLastTick = 0;\n\t\t}\n\n\t\t// @ts-expect-error\n\t\tlet quadtree = ecs.quadtree;\n\t\tlet start = performance.now();\n\n\t\t// Use quadtree to see who we are colliding with\n\t\tfor(let i = 0; i < movingEntities.length; i++) {\n\t\t\tlet eid = movingEntities[i];\n\t\t\tlet shipColor = controller.color[controlled.owner[eid]];\n\n\t\t\t// Try to find the nearest enemy\n\t\t\tlet rect = {\n\t\t\t\tx: position.x[eid] - 50,\n\t\t\t\ty: position.y[eid] - 50,\n\t\t\t\twidth: position.width[eid] + 100,\n\t\t\t\theight: position.height[eid] + 100\n\t\t\t};\n\t\t\tlet enemies = getEnemiesInRange(quadtree, ecs, rect, eid, shipColor, world);\n\t\t\tif(enemies.length === 0) {\n\t\t\t\trect.x -= 100;\n\t\t\t\trect.y -= 100;\n\t\t\t\trect.width += 200;\n\t\t\t\trect.height += 200;\n\t\t\t\tenemies = getEnemiesInRange(quadtree, ecs, rect, eid, shipColor, world);\n\t\t\t}\n\t\n\t\t\tenemies.sort((a, b) => {\n\t\t\t\treturn euclideanDistance(position.x[a], position.y[a], position.x[eid], position.y[eid]) - euclideanDistance(position.x[b], position.y[b], position.x[eid], position.y[eid]);\n\t\t\t});\n\t\t\tlet enemy = enemies[0] ?? 0;\n\n\t\t\t// If no enemies that quadtree could easily find, just head for the nearest station\n\t\t\tif(!enemy) {\n\t\t\t\tlet stations = controllerQuery(ecs).filter(stationEid => controller.color[stationEid] !== shipColor && !health.dead[stationEid]);\n\t\t\t\tstations.sort((a, b) => {\n\t\t\t\t\treturn euclideanDistance(position.x[a], position.y[a], position.x[eid], position.y[eid]) - euclideanDistance(position.x[b], position.y[b], position.x[eid], position.y[eid]);\n\t\t\t\t});\n\n\t\t\t\tenemy = stations[0] ?? 0;\n\t\t\t}\n\n\t\t\tattack.target[eid] = enemy;\n\n\t\t\tif(i % 10 === 0 && i > minCountToUpdate) {\n\t\t\t\t// Check how long we have been running for\n\t\t\t\tif(performance.now() - start > (delta * 1_000 / 2)) {\n\t\t\t\t\tmovingEntities = movingEntities.slice(i);\n\t\t\t\t\treturn ecs;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmovingEntities = [];\n\t\treturn ecs;\n\t};\n}\n\nfunction getEnemiesInRange(quadtree: any, ecs: IWorld, range: { x: number, y: number, width: number, height: number }, eid: number, shipColor: number, world: World) : Array<number> {\n\tconst controlled = world.components.controlled;\n\tconst controller = world.components.controller;\n\n\tlet entitiesInRange = quadtree.retrieve(new Rectangle(range)).map((result: any) => result.data.eid).filter((otherEid: number) => otherEid !== eid);\n\treturn entitiesInRange.filter((otherEid: number) => {\n\t\t// Ship\n\t\tif(hasComponent(ecs, controlled, otherEid)) {\n\t\t\tlet stationEid = controlled.owner[otherEid];\n\t\t\treturn controller.color[stationEid] !== shipColor;\n\t\t}\n\t\t// Station\n\t\telse if(hasComponent(ecs, controller, otherEid)) {\n\t\t\treturn controller.color[otherEid] !== shipColor;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t});\n}","import { defineQuery, IWorld } from 'bitecs';\nimport World from '../entities/world';\nimport { Quadtree, Rectangle } from '@timohausmann/quadtree-ts/src/index.esm';\n\nexport default function createQuadTreeSystem(world: World) {\n\tconst position = world.components.position;\n\tconst health = world.components.health;\n\tlet collidableQuery = defineQuery([position, health]);\n\n\treturn (ecs: IWorld) => {\n\t\t// Create and populate quadtree\n\t\tlet quadtree = new Quadtree({\n\t\t\twidth: world.bounds.width,\n\t\t\theight: world.bounds.height\n\t\t});\n\t\tcollidableQuery(ecs).forEach(eid => {\n\t\t\tif(health.dead[eid]) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tquadtree.insert(new Rectangle({\n\t\t\t\tx: position.x[eid],\n\t\t\t\ty: position.y[eid],\n\t\t\t\twidth: position.width[eid],\n\t\t\t\theight: position.height[eid],\n\t\t\t\tdata: {\n\t\t\t\t\teid\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\n\t\t// @ts-expect-error\n\t\tecs.quadtree = quadtree;\n\n\t\treturn ecs;\n\t};\n}","import { defineQuery, IWorld } from 'bitecs';\nimport World from '../entities/world';\n\nexport default function updateHealthTimersSystem(world: World) {\n\tconst health = world.components.health;\n\tlet healthQuery = defineQuery([health]);\n\n\treturn (ecs: IWorld, delta: number) => {\n\t\thealthQuery(ecs).forEach(eid => {\n\t\t\thealth.timeSinceTakenDamage[eid] += delta;\n\n\t\t\tif(health.shields[eid] < health.maxShields[eid]) {\n\t\t\t\thealth.timeSinceShieldRegeneration[eid] += delta;\n\t\t\t\tif(health.timeSinceShieldRegeneration[eid] > health.timeToRegenerateShields[eid]) {\n\t\t\t\t\thealth.shields[eid]++;\n\t\t\t\t\thealth.timeSinceShieldRegeneration[eid] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn ecs;\n\t};\n}","import { defineQuery, IWorld } from 'bitecs';\nimport World from '../entities/world';\nimport computeAngle from '@/math/compute-angle';\nconst PhaserMath = require('phaser/src/math');\n\nexport default function moveToTargetSystem(world: World) {\n\tconst position = world.components.position;\n\tconst velocity = world.components.velocity;\n\tconst attack = world.components.attack;\n\tconst health = world.components.health;\n\tlet movingQuery = defineQuery([velocity, attack]);\n\n\treturn (ecs: IWorld) => {\n\t\tmovingQuery(ecs).forEach(eid => {\n\t\t\tlet target = attack.target[eid];\n\t\t\tif(!target || health.dead[target]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet force = getMoveTowardsForce(position, eid, target);\n\t\t\tlet newVelocity = new PhaserMath.Vector2(velocity.x[eid] + force.x * 4, velocity.y[eid] + force.y * 4);\n\t\t\tnewVelocity.normalize();\n\n\t\t\tvelocity.x[eid] = newVelocity.x * velocity.speed[eid];\n\t\t\tvelocity.y[eid] = newVelocity.y * velocity.speed[eid];\n\t\t\tposition.angle[eid] = computeAngle(velocity.x[eid], velocity.y[eid]);\n\t\t});\n\n\t\treturn ecs;\n\t};\n}\n\nfunction getMoveTowardsForce(position: any, eid: number, otherEid: number) {\n\tlet force = new PhaserMath.Vector2(position.x[otherEid] - position.x[eid], position.y[otherEid] - position.y[eid]);\n\tforce.normalize();\n\treturn force;\n}","import {\n\tcreateWorld,\n\tIWorld,\n\tremoveEntity\n} from 'bitecs';\nimport Entity from './entity';\nimport { EventEmitter } from 'eventemitter3';\nimport Station from './station';\nimport spawnShipSystem from '../systems/spawn-ship-system';\nimport components from '../components';\nimport velocitySystem from '../systems/velocity-system';\nimport collisionSystem from '../systems/collision-system';\nimport targetEnemySystem from '../systems/target-enemy-system';\nimport createQuadTreeSystem from '../systems/create-quad-tree-system';\nimport updateHealthTimersSystem from '../systems/update-health-timers-system';\nimport moveToTargetSystem from '../systems/move-to-target-system';\n\nexport default class World extends EventEmitter {\n\tecs: IWorld;\n\teidMap: Map<number, Entity> = new Map();\n\tbounds: {\n\t\twidth: number,\n\t\theight: number\n\t} = { width: 0, height: 0 };\n\tcomponents = components;\n\tsystems: Array<(world: IWorld, delta: number) => IWorld> = [];\n\tsystemUpdates: { [s: string]: Array<number> } = {};\n\n\tget entities() { return [...this.eidMap.values()]; }\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.ecs = createWorld();\n\n\t\tthis.addSystem('quadTreeSystem', createQuadTreeSystem(this));\n\t\tthis.addSystem('spawnShipSystem', spawnShipSystem(this));\n\t\tthis.addSystem('targetEnemySystem', targetEnemySystem(this));\n\t\tthis.addSystem('moveToTargetSystem', moveToTargetSystem(this));\n\t\tthis.addSystem('velocitySystem', velocitySystem(this));\n\t\tthis.addSystem('collisionSystem', collisionSystem(this));\n\t\tthis.addSystem('updateHealthTimersSystem', updateHealthTimersSystem(this));\n\t}\n\n\tload(config: any) {\n\t\tconfig.entities.forEach((entityConfig: any) => {\n\t\t\tlet entity;\n\t\t\tswitch(entityConfig.type) {\n\t\t\t\tcase 'station':\n\t\t\t\t\tentity = new Station(this);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tentity = new Entity(this);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentity.load(entityConfig);\n\t\t\tthis.addEntity(entity);\n\t\t});\n\n\t\tif(config.bounds) {\n\t\t\tthis.bounds = config.bounds;\n\t\t}\n\t}\n\taddEntity(entity: Entity) {\n\t\tthis.emit('entity-added', entity);\n\t\tthis.eidMap.set(entity.eid, entity);\n\t}\n\tremoveEntity(eid: number) {\n\t\tremoveEntity(this.ecs, eid);\n\t\tthis.eidMap.delete(eid);\n\t}\n\tgetEntity(eid: number) {\n\t\treturn this.eidMap.get(eid) ?? null;\n\t}\n\n\tupdate(delta: number) {\n\t\tthis.systems.forEach(system => {\n\t\t\tsystem(this.ecs, delta);\n\t\t});\n\t}\n\n\taddSystem(name: string, update: (world: IWorld, delta: number) => void) {\n\t\tthis.systems.push((world: IWorld, delta: number) => {\n\t\t\tlet start = performance.now();\n\t\t\tupdate(world, delta);\n\t\t\tthis.systemUpdates[name].push(performance.now() - start);\n\n\t\t\treturn world;\n\t\t});\n\t\tthis.systemUpdates[name] = [];\n\t}\n}","import { defineComponent as _defineComponent } from 'vue'\nimport { toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, unref as _unref, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, normalizeStyle as _normalizeStyle, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\"\n\nconst _withScopeId = n => (_pushScopeId(\"data-v-4e495fc6\"),n=n(),_popScopeId(),n)\nconst _hoisted_1 = { class: \"home\" }\nconst _hoisted_2 = { class: \"list\" }\nconst _hoisted_3 = { style: {\"color\":\"red\"} }\nconst _hoisted_4 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(\"p\", null, null, -1))\nconst _hoisted_5 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(\"div\", { id: \"phaser-container-bitecs\" }, null, -1))\n\nimport { ref, onMounted, onBeforeUnmount, Ref } from 'vue';\nimport Phaser from 'phaser';\nimport generateScene from '@/data/generate-scene';\nimport World from './entities/world';\nimport Entity from './entities/entity';\nimport Station from './entities/station';\nimport Ship from './entities/ship';\nimport { Changed, defineQuery } from 'bitecs';\nimport components from './components';\n\n\nexport default /*#__PURE__*/_defineComponent({\n  setup(__props) {\n\nlet world = new World();\nconst minUpdateTime = ref(0);\nconst maxUpdateTime = ref(0);\nconst avgUpdateTime = ref(0);\nconst stationsCount = ref(0);\nconst shipsCount = ref(0);\nconst stationShips = ref([]) as Ref<Array<{ eid: number, color: number, displayColor: string, ships: number }>>;\nconst stationQuery = defineQuery([components.controller]);\nconst systemUpdates = ref([]) as Ref<Array<{ name: string, min: number, avg: number, max: number }>>;\n\nlet game: Phaser.Game | null;\nonMounted(() => {\n\tlet updateTicks = 0;\n\tlet updateTimes: Array<number> = [];\n\n\tconst width = window.innerWidth / 3 * 2;\n\tconst height = window.innerHeight / 3 * 2;\n\tlet paused = false;\n\tconst changedPositionQuery = defineQuery([ Changed(components.position) ]);\n\tconst changedHealthQuery = defineQuery([ Changed(components.health) ]);\n\tconst controlledQuery = defineQuery([components.controlled]);\n\tconst eidSpriteMap = new Map<number, any>();\n\tgame = new Phaser.Game({\n\t\ttype: Phaser.AUTO,\n\t\twidth,\n\t\theight,\n\t\tparent: 'phaser-container-bitecs',\n\t\t// @ts-expect-error\n\t\tscene: {\n\t\t\tpreload() {\n\t\t\t\tthis.load.image('boid', 'boid.png');\n\t\t\t\tthis.load.image('station', 'station.png');\n\t\t\t\tthis.load.image('shield', 'shield3.png');\n\t\t\t},\n\t\t\tcreate() {\n\t\t\t\tworld.on('entity-added', (entity: Entity) => {\n\t\t\t\t\tlet image = this.add.image(entity.x, entity.y, entity.key) as any;\n\t\t\t\t\timage.setScale(entity.width / image.width, entity.height / image.height);\n\t\t\t\t\timage.shieldImage = this.add.image(entity.x, entity.y, 'shield');\n\t\t\t\t\timage.shieldImage.setScale(entity.width / image.shieldImage.width * 2, entity.height / image.shieldImage.height * 2);\n\t\t\t\t\timage.shieldImage.visible = entity.shields > 0;\n\t\t\t\t\tif(entity instanceof Station || entity instanceof Ship) {\n\t\t\t\t\t\timage.setTint(entity.color);\n\t\t\t\t\t}\n\t\t\t\t\teidSpriteMap.set(entity.eid, image);\n\t\t\t\t});\n\n\t\t\t\tworld.load(generateScene({\n\t\t\t\t\tstations: 6,\n\t\t\t\t\tshipsPerStation: 100,\n\t\t\t\t\twidth,\n\t\t\t\t\theight\n\t\t\t\t}));\n\n\t\t\t\tlet stations = world.entities.filter(entity => entity instanceof Station) as Array<Station>;\n\t\t\t\tstationShips.value = stations.map(station => {\n\t\t\t\t\tlet displayColor = '#' + station.color.toString(16);\n\t\t\t\t\tif(displayColor === '#ffffff') {\n\t\t\t\t\t\tdisplayColor = '#00000';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\teid: station.eid,\n\t\t\t\t\t\tcolor: station.color,\n\t\t\t\t\t\tdisplayColor,\n\t\t\t\t\t\tships: 0\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\tthis.input.keyboard.on('keydown-SPACE', () => {\n\t\t\t\t\tpaused = !paused;\n\t\t\t\t});\n\n\t\t\t\tObject.keys(world.systemUpdates).forEach(systemName => {\n\t\t\t\t\tsystemUpdates.value.push({\n\t\t\t\t\t\tname: systemName,\n\t\t\t\t\t\tmin:0,\n\t\t\t\t\t\tavg: 0,\n\t\t\t\t\t\tmax: 0\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\t\t\tupdate(time: number, delta: number) {\n\t\t\t\tif(paused) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet start = performance.now();\n\t\t\t\tworld.update(delta / 1_000);\n\n\t\t\t\tchangedPositionQuery(world.ecs).forEach(eid => {\n\t\t\t\t\tlet image = eidSpriteMap.get(eid);\n\t\t\t\t\tif(!image) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\timage.x = image.shieldImage.x = components.position.x[eid];\n\t\t\t\t\timage.y = image.shieldImage.y = components.position.y[eid];\n\t\t\t\t\timage.angle = image.shieldImage.angle = components.position.angle[eid];\n\t\t\t\t});\n\t\t\t\tchangedHealthQuery(world.ecs).forEach(eid => {\n\t\t\t\t\tlet image = eidSpriteMap.get(eid);\n\t\t\t\t\tif(!image) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\timage.shieldImage.visible = components.health.shields[eid] > 0;\n\t\t\t\t\tif(components.health.dead[eid]) {\n\t\t\t\t\t\timage.destroy();\n\t\t\t\t\t\timage.shieldImage.destroy();\n\t\t\t\t\t\teidSpriteMap.delete(eid);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tlet end = performance.now();\n\n\t\t\t\tupdateTimes.push(end - start);\n\t\t\t\tupdateTicks += delta;\n\t\t\t\tif(updateTicks > 1_000) {\n\t\t\t\t\tminUpdateTime.value = updateTimes.reduce((min, time) => {\n\t\t\t\t\t\treturn Math.min(min, time);\n\t\t\t\t\t}, 1_000_000);\n\t\t\t\t\tmaxUpdateTime.value = updateTimes.reduce((max, time) => {\n\t\t\t\t\t\treturn Math.max(max, time);\n\t\t\t\t\t}, 0);\n\t\t\t\t\tavgUpdateTime.value = updateTimes.reduce((total, time) => {\n\t\t\t\t\t\treturn total + time;\n\t\t\t\t\t}, 0) / updateTimes.length;\n\t\t\t\t\tupdateTimes = [];\n\t\t\t\t\tupdateTicks = 0;\n\n\t\t\t\t\tstationsCount.value = world.entities.filter(entity => entity instanceof Station).length;\n\n\t\t\t\t\tlet stations = stationQuery(world.ecs).filter(eid => !components.health.dead[eid]);\n\t\t\t\t\tlet ships = controlledQuery(world.ecs).filter(eid => !components.health.dead[eid]);\n\t\t\t\t\tshipsCount.value = ships.length;\n\t\t\t\t\tstationShips.value.forEach(val => {\n\t\t\t\t\t\tlet matchingStationEid = stations.find(eid => components.controller.color[eid] === val.color);\n\t\t\t\t\t\tif(matchingStationEid !== undefined) {\n\t\t\t\t\t\t\tval.ships = ships.filter(eid => components.controlled.owner[eid] === val.eid).length;\n\t\t\t\t\t\t} else if(val.ships > 0) {\n\t\t\t\t\t\t\t// paused = true;\n\t\t\t\t\t\t\tval.ships = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tsystemUpdates.value = [];\n\t\t\t\t\tObject.keys(world.systemUpdates).forEach(systemName => {\n\t\t\t\t\t\tlet updates = world.systemUpdates[systemName];\n\n\t\t\t\t\t\tsystemUpdates.value.push({\n\t\t\t\t\t\t\tname: systemName,\n\t\t\t\t\t\t\tmin: updates.reduce((min, time) => {\n\t\t\t\t\t\t\t\treturn Math.min(min, time);\n\t\t\t\t\t\t\t}, 1_000_000),\n\t\t\t\t\t\t\tavg: updates.reduce((total, time) => {\n\t\t\t\t\t\t\t\treturn total + time;\n\t\t\t\t\t\t\t}, 0) / updates.length,\n\t\t\t\t\t\t\tmax: updates.reduce((max, time) => {\n\t\t\t\t\t\t\t\treturn Math.max(max, time);\n\t\t\t\t\t\t\t}, 0)\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tworld.systemUpdates[systemName] = [];\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n});\nonBeforeUnmount(() => {\n\tif(game) {\n\t\tgame.destroy();\n\t\tgame = null;\n\t} \n});\n\nfunction addShips() {\n\tstationQuery(world.ecs).forEach(eid => {\n\t\tworld.components.controller.money[eid] += 10;\n\t});\n}\n\nreturn (_ctx: any,_cache: any) => {\n  return (_openBlock(), _createElementBlock(\"div\", _hoisted_1, [\n    _createElementVNode(\"div\", _hoisted_2, [\n      _createElementVNode(\"div\", _hoisted_3, \"mainThread: \" + _toDisplayString(maxUpdateTime.value.toFixed(2)) + \" (\" + _toDisplayString(avgUpdateTime.value.toFixed(2)) + \" avg) ms\", 1),\n      (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(systemUpdates), (system) => {\n        return (_openBlock(), _createElementBlock(\"div\", {\n          key: system.name\n        }, _toDisplayString(system.name) + \": \" + _toDisplayString(system.max.toFixed(2)) + \" (\" + _toDisplayString(system.avg.toFixed(2)) + \" avg) ms\", 1))\n      }), 128)),\n      _hoisted_4,\n      _createElementVNode(\"div\", null, \"Entities: \" + _toDisplayString(stationsCount.value) + \" stations and \" + _toDisplayString(shipsCount.value) + \" ships\", 1),\n      (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(stationShips), (station) => {\n        return (_openBlock(), _createElementBlock(\"span\", {\n          class: \"station-list\",\n          key: station.color,\n          style: _normalizeStyle({ color: station.displayColor })\n        }, _toDisplayString('#' + station.color.toString(16)) + \": \" + _toDisplayString(station.ships), 5))\n      }), 128)),\n      _createElementVNode(\"div\", null, [\n        _createElementVNode(\"button\", { onClick: addShips }, \"Add Ships\")\n      ])\n    ]),\n    _hoisted_5\n  ]))\n}\n}\n\n})","import script from \"./BitECSGame.vue?vue&type=script&setup=true&lang=ts\"\nexport * from \"./BitECSGame.vue?vue&type=script&setup=true&lang=ts\"\n\nimport \"./BitECSGame.vue?vue&type=style&index=0&id=4e495fc6&scoped=true&lang=css\"\n\nimport exportComponent from \"/home/runner/work/ecs-arraybuffer/ecs-arraybuffer/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['__scopeId',\"data-v-4e495fc6\"]])\n\nexport default __exports__"],"names":["Quadtree","constructor","props","level","this","bounds","x","y","width","height","maxObjects","maxLevels","objects","nodes","getIndex","obj","qtIndex","split","coords","i","insert","length","indexes","push","k","retrieve","returnObjects","concat","filter","item","index","indexOf","clear","Rectangle","data","node","boundsCenterX","boundsCenterY","startIsNorth","startIsWest","endIsEast","endIsSouth","distance","x1","y1","x2","y2","Math","sqrt","euclideanDistance","TYPES_ENUM","i8","ui8","ui8c","i16","ui16","i32","ui32","f32","f64","eid","TYPES_NAMES","TYPES","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","UNSIGNED_MAX","uint8","uint16","uint32","roundToMultiple","mul","ceil","roundToMultiple4","$storeRef","Symbol","$storeSize","$storeMaps","$storeFlattened","$storeBase","$storeType","$storeArrayElementCounts","$storeSubarrays","$subarrayCursors","$subarray","$parentArray","$tagStore","$indexType","$indexBytes","$isEidType","stores","resize","ta","size","newBuffer","ArrayBuffer","BYTES_PER_ELEMENT","newTa","set","createShadow","store","key","isView","slice","shadowStore","map","_","start","end","subarray","resizeSubarray","metadata","storeSize","cursors","type","indexType","arrayElementCount","array","start2","end2","resizeRecursive","Object","keys","forEach","Array","isArray","resizeStore","resetStoreFor","fill","createTypeStore","totalBytes","buffer","createArrayStore","Error","isArrayType","createStore","schema","$store","JSON","parse","stringify","arrayElementCounts","collectArrayElementCounts","s","reduce","a","recursiveTransform","assign","SparseSet","dense","sparse","sort","comparator","result","prototype","call","has","val","add","remove","swapped","pop","setSerializationResized","v","not","fn","storeFlattened","c","isFullComponent","isModifier","$entityMasks","$entityComponents","$entitySparseSet","$entityArray","defaultSize","globalEntityCursor","globalSize","resizeThreshold","getGlobalSize","removed","resetGlobals","setDefaultSize","newSize","oldSize","resizeWorlds","resizeComponents","console","info","getEntityCursor","eidToWorld","Map","addEntity","world","amount","round","shift","$notQueries","q","match","queryCheckEntity","queryAddEntity","Set","removeEntity","$queries","queryRemoveEntity","delete","$localEntities","$localEntityLookup","get","Changed","Any","comps","All","None","$queryAny","$queryAll","$queryNone","$queryMap","$dirtyQueries","$queryComponents","registerQuery","query","components2","notComponents","changedComponents","comp","mod","$componentMap","registerComponent","mapComponents","allComponents","sparseSet","archetypes","changed","toRemove","entered","exited","generations","generationId","includes","reduceBitflags","bitflag","masks","notMasks","hasMasks","flatProps","getOwnPropertySymbols","shadows","components","queries","generateShadow","pid","$","prop","diff","clearDiff","dirty","shadow","i2","flatten","aggregateComponentsFor","f","name","defineQuery","args","any","all","none","commitRemovals","qMask","qNotMask","eMask","queryCommitRemovals","component","defineComponent","incrementBitflag","$bitflag","$size","notQueries","changedQueries","hasComponent","registeredComponent","mask","addComponent","reset","$resizeThreshold","$archetypes","worlds","createWorld","resetWorld","Types","Entity","EventEmitter","position","shields","health","maxShields","timeToRegenerateShields","timeSinceShieldRegeneration","timeSinceTakenDamage","dead","super","ecs","load","config","value","Station","color","controller","money","Ship","controlled","owner","velocityX","velocity","velocityY","station","getEntity","attack","speed","spawnShipSystem","stationQuery","stations","stationEid","ship","random","angle","computeAngle","target","velocitySystem","shipQuery","delta","ships","shipEid","collisionSystem","movingQuery","TIME_BETWEEN_TICKS","timeSinceLastTick","minCountToUpdate","quadtree","performance","now","entitiesInRange","otherEid","shipColor","enemiesInRange","collisions","max","collide","canTakeDamage","enemyWorth","takeDamage","damage","controlledShips","targetEnemySystem","controllerQuery","movingEntities","rect","enemies","getEnemiesInRange","b","enemy","range","createQuadTreeSystem","collidableQuery","updateHealthTimersSystem","healthQuery","PhaserMath","require","moveToTargetSystem","force","getMoveTowardsForce","newVelocity","Vector2","normalize","World","entities","eidMap","values","addSystem","entityConfig","entity","emit","update","systems","system","systemUpdates","_withScopeId","n","_pushScopeId","_popScopeId","_hoisted_1","class","_hoisted_2","_hoisted_3","style","_hoisted_4","_createElementVNode","_hoisted_5","id","_defineComponent","setup","__props","minUpdateTime","ref","maxUpdateTime","avgUpdateTime","stationsCount","shipsCount","stationShips","game","addShips","onMounted","updateTicks","updateTimes","window","innerWidth","innerHeight","paused","changedPositionQuery","changedHealthQuery","controlledQuery","eidSpriteMap","Phaser","parent","scene","preload","image","create","on","setScale","shieldImage","visible","setTint","generateScene","shipsPerStation","displayColor","toString","input","keyboard","systemName","min","avg","time","destroy","total","matchingStationEid","find","undefined","updates","onBeforeUnmount","_ctx","_cache","_openBlock","_createElementBlock","_toDisplayString","toFixed","_Fragment","_renderList","_unref","_normalizeStyle","onClick","__exports__"],"sourceRoot":""}