{"version":3,"file":"js/bitecs.d6b7cf39.js","mappings":"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","sources":["webpack://ecs-arraybuffer/../src/Constants.js","webpack://ecs-arraybuffer/../src/Storage.js","webpack://ecs-arraybuffer/../src/Util.js","webpack://ecs-arraybuffer/../src/Serialize.js","webpack://ecs-arraybuffer/../src/Entity.js","webpack://ecs-arraybuffer/../src/Query.js","webpack://ecs-arraybuffer/../src/Component.js","webpack://ecs-arraybuffer/../src/World.js","webpack://ecs-arraybuffer/../src/index.js","webpack://ecs-arraybuffer/./src/bitecs/entities/entity.ts","webpack://ecs-arraybuffer/./src/bitecs/entities/station.ts","webpack://ecs-arraybuffer/./src/bitecs/entities/ship.ts","webpack://ecs-arraybuffer/./src/bitecs/systems/spawn-ship-system.ts","webpack://ecs-arraybuffer/./src/bitecs/components/position.ts","webpack://ecs-arraybuffer/./src/bitecs/components/controller.ts","webpack://ecs-arraybuffer/./src/bitecs/components/velocity.ts","webpack://ecs-arraybuffer/./src/bitecs/components/health.ts","webpack://ecs-arraybuffer/./src/bitecs/components/controlled.ts","webpack://ecs-arraybuffer/./src/bitecs/components/attack.ts","webpack://ecs-arraybuffer/./src/bitecs/components/index.ts","webpack://ecs-arraybuffer/./src/bitecs/systems/velocity-system.ts","webpack://ecs-arraybuffer/./src/bitecs/systems/collision-system.ts","webpack://ecs-arraybuffer/./src/bitecs/systems/target-enemy-system.ts","webpack://ecs-arraybuffer/./src/bitecs/systems/create-quad-tree-system.ts","webpack://ecs-arraybuffer/./src/bitecs/systems/update-health-timers-system.ts","webpack://ecs-arraybuffer/./src/bitecs/systems/move-to-target-system.ts","webpack://ecs-arraybuffer/./src/bitecs/entities/world.ts","webpack://ecs-arraybuffer/./node_modules/vue-loader/dist/index.js","webpack://ecs-arraybuffer/./src/bitecs/BitECSGame.vue"],"sourcesContent":["export const TYPES_ENUM = {\n  i8: 'i8',\n  ui8: 'ui8',\n  ui8c: 'ui8c',\n  i16: 'i16',\n  ui16: 'ui16',\n  i32: 'i32',\n  ui32: 'ui32',\n  f32: 'f32',\n  f64: 'f64',\n  eid: 'eid',\n}\n\nexport const TYPES_NAMES = {\n  i8: 'Int8',\n  ui8: 'Uint8',\n  ui8c: 'Uint8Clamped',\n  i16: 'Int16',\n  ui16: 'Uint16',\n  i32: 'Int32',\n  ui32: 'Uint32',\n  eid: 'Uint32',\n  f32: 'Float32',\n  f64: 'Float64'\n}\n\nexport const TYPES = {\n  i8: Int8Array,\n  ui8: Uint8Array,\n  ui8c: Uint8ClampedArray,\n  i16: Int16Array,\n  ui16: Uint16Array,\n  i32: Int32Array,\n  ui32: Uint32Array,\n  f32: Float32Array,\n  f64: Float64Array,\n  eid: Uint32Array,\n}\n\nexport const UNSIGNED_MAX = {\n  uint8: 2**8,\n  uint16: 2**16,\n  uint32: 2**32\n}\n","import { TYPES, TYPES_ENUM, TYPES_NAMES, UNSIGNED_MAX } from './Constants.js'\n// import { createAllocator } from './Allocator.js'\n\nconst roundToMultiple = mul => x => Math.ceil(x / mul) * mul\nconst roundToMultiple4 = roundToMultiple(4)\n\nexport const $storeRef = Symbol('storeRef')\nexport const $storeSize = Symbol('storeSize')\nexport const $storeMaps = Symbol('storeMaps')\nexport const $storeFlattened = Symbol('storeFlattened')\nexport const $storeBase = Symbol('storeBase')\nexport const $storeType = Symbol('storeType')\n\nexport const $storeArrayElementCounts = Symbol('storeArrayElementCounts')\nexport const $storeSubarrays = Symbol('storeSubarrays')\nexport const $subarrayCursors = Symbol('subarrayCursors')\nexport const $subarray = Symbol('subarray')\nexport const $subarrayFrom = Symbol('subarrayFrom')\nexport const $subarrayTo = Symbol('subarrayTo')\nexport const $parentArray = Symbol('parentArray')\nexport const $tagStore = Symbol('tagStore')\n\nexport const $queryShadow = Symbol('queryShadow')\nexport const $serializeShadow = Symbol('serializeShadow')\n\nexport const $indexType = Symbol('indexType')\nexport const $indexBytes = Symbol('indexBytes')\n\nexport const $isEidType = Symbol('isEidType')\n\nconst stores = {}\n\n// const alloc = createAllocator()\n\nexport const resize = (ta, size) => {\n  const newBuffer = new ArrayBuffer(size * ta.BYTES_PER_ELEMENT)\n  const newTa = new ta.constructor(newBuffer)\n  newTa.set(ta, 0)\n  return newTa\n}\n\nexport const createShadow = (store, key) => {\n  if (!ArrayBuffer.isView(store)) {\n    const shadowStore = store[$parentArray].slice(0)\n    store[key] = store.map((_,eid) => {\n      const { length } = store[eid]\n      const start = length * eid\n      const end = start + length\n      return shadowStore.subarray(start, end)\n    })\n  } else {\n    store[key] = store.slice(0)\n  }\n}\n\nconst resizeSubarray = (metadata, store, storeSize) => {\n  const cursors = metadata[$subarrayCursors]\n  let type = store[$storeType]\n  const length = store[0].length\n  const indexType =\n    length <= UNSIGNED_MAX.uint8\n      ? TYPES_ENUM.ui8\n      : length <= UNSIGNED_MAX.uint16\n        ? TYPES_ENUM.ui16\n        : TYPES_ENUM.ui32\n\n  if (cursors[type] === 0) {\n\n    const arrayElementCount = metadata[$storeArrayElementCounts][type]\n    \n    // // for threaded impl\n    // // const summedBytesPerElement = Array(arrayCount).fill(0).reduce((a, p) => a + TYPES[type].BYTES_PER_ELEMENT, 0)\n    // // const totalBytes = roundToMultiple4(summedBytesPerElement * summedLength * size)\n    // // const buffer = new SharedArrayBuffer(totalBytes)\n\n    const array = new TYPES[type](roundToMultiple4(arrayElementCount * storeSize))\n\n    array.set(metadata[$storeSubarrays][type])\n    \n    metadata[$storeSubarrays][type] = array\n    \n    array[$indexType] = TYPES_NAMES[indexType]\n    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\n  }\n\n  const start = cursors[type]\n  const end = start + (storeSize * length)\n  cursors[type] = end\n\n  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end)\n\n  // pre-generate subarrays for each eid\n  for (let eid = 0; eid < storeSize; eid++) {\n    const start = length * eid\n    const end = start + length\n    store[eid] = store[$parentArray].subarray(start, end)\n    store[eid][$indexType] = TYPES_NAMES[indexType]\n    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\n    store[eid][$subarray] = true\n  }\n\n}\n\nconst resizeRecursive = (metadata, store, size) => {\n  Object.keys(store).forEach(key => {\n    const ta = store[key]\n    if (Array.isArray(ta)) {\n      resizeSubarray(metadata, ta, size)\n      store[$storeFlattened].push(ta)\n    } else if (ArrayBuffer.isView(ta)) {\n      store[key] = resize(ta, size)\n      store[$storeFlattened].push(store[key])\n    } else if (typeof ta === 'object') {\n      resizeRecursive(metadata, store[key], size)\n    }\n  })\n}\n\nexport const resizeStore = (store, size) => {\n  if (store[$tagStore]) return\n  store[$storeSize] = size\n  store[$storeFlattened].length = 0\n  Object.keys(store[$subarrayCursors]).forEach(k => {\n    store[$subarrayCursors][k] = 0\n  })\n  resizeRecursive(store, store, size)\n}\n\nexport const resetStore = store => {\n  if (store[$storeFlattened]) {\n    store[$storeFlattened].forEach(ta => {\n      ta.fill(0)\n    })\n    Object.keys(store[$storeSubarrays]).forEach(key => {\n      store[$storeSubarrays][key].fill(0)\n    })\n  }\n}\n\nexport const resetStoreFor = (store, eid) => {\n  if (store[$storeFlattened]) {\n    store[$storeFlattened].forEach(ta => {\n      if (ArrayBuffer.isView(ta)) ta[eid] = 0\n      else ta[eid].fill(0)\n    })\n  }\n}\n\nconst createTypeStore = (type, length) => {\n  const totalBytes = length * TYPES[type].BYTES_PER_ELEMENT\n  const buffer = new ArrayBuffer(totalBytes)\n  const store = new TYPES[type](buffer)\n  store[$isEidType] = type === TYPES_ENUM.eid\n  return store\n}\n\nexport const parentArray = store => store[$parentArray]\n\nconst createArrayStore = (metadata, type, length) => {\n  const storeSize = metadata[$storeSize]\n  const store = Array(storeSize).fill(0)\n  store[$storeType] = type\n  store[$isEidType] = type === TYPES_ENUM.eid\n\n  const cursors = metadata[$subarrayCursors]\n  const indexType =\n    length <= UNSIGNED_MAX.uint8\n      ? TYPES_ENUM.ui8\n      : length <= UNSIGNED_MAX.uint16\n        ? TYPES_ENUM.ui16\n        : TYPES_ENUM.ui32\n\n  if (!length) throw new Error('bitECS - Must define component array length')\n  if (!TYPES[type]) throw new Error(`bitECS - Invalid component array property type ${type}`)\n\n  // create buffer for type if it does not already exist\n  if (!metadata[$storeSubarrays][type]) {\n    const arrayElementCount = metadata[$storeArrayElementCounts][type]\n\n    // for threaded impl\n    // const summedBytesPerElement = Array(arrayCount).fill(0).reduce((a, p) => a + TYPES[type].BYTES_PER_ELEMENT, 0)\n    // const totalBytes = roundToMultiple4(summedBytesPerElement * summedLength * size)\n    // const buffer = new SharedArrayBuffer(totalBytes)\n\n    const array = new TYPES[type](roundToMultiple4(arrayElementCount * storeSize))\n    array[$indexType] = TYPES_NAMES[indexType]\n    array[$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\n\n    metadata[$storeSubarrays][type] = array\n    \n  }\n\n  const start = cursors[type]\n  const end = start + (storeSize * length)\n  cursors[type] = end\n\n  store[$parentArray] = metadata[$storeSubarrays][type].subarray(start, end)\n\n  // pre-generate subarrays for each eid\n  for (let eid = 0; eid < storeSize; eid++) {\n    const start = length * eid\n    const end = start + length\n    store[eid] = store[$parentArray].subarray(start, end)\n    store[eid][$indexType] = TYPES_NAMES[indexType]\n    store[eid][$indexBytes] = TYPES[indexType].BYTES_PER_ELEMENT\n    store[eid][$subarray] = true\n  }\n\n  return store\n}\n\nconst isArrayType = x => Array.isArray(x) && typeof x[0] === 'string' && typeof x[1] === 'number'\n\nexport const createStore = (schema, size) => {\n  const $store = Symbol('store')\n\n  if (!schema || !Object.keys(schema).length) {\n    // tag component\n    stores[$store] = {\n      [$storeSize]: size,\n      [$tagStore]: true,\n      [$storeBase]: () => stores[$store]\n    }\n    return stores[$store]\n  }\n\n  schema = JSON.parse(JSON.stringify(schema))\n\n  const arrayElementCounts = {}\n  const collectArrayElementCounts = s => {\n    const keys = Object.keys(s)\n    for (const k of keys) {\n      if (isArrayType(s[k])) {\n        if (!arrayElementCounts[s[k][0]]) arrayElementCounts[s[k][0]] = 0\n        arrayElementCounts[s[k][0]] += s[k][1]\n      } else if (s[k] instanceof Object) {\n        collectArrayElementCounts(s[k])\n      }\n    }\n  }\n  collectArrayElementCounts(schema)\n\n  const metadata = {\n    [$storeSize]: size,\n    [$storeMaps]: {},\n    [$storeSubarrays]: {},\n    [$storeRef]: $store,\n    [$subarrayCursors]: Object.keys(TYPES).reduce((a, type) => ({ ...a, [type]: 0 }), {}),\n    [$storeFlattened]: [],\n    [$storeArrayElementCounts]: arrayElementCounts\n  }\n\n  if (schema instanceof Object && Object.keys(schema).length) {\n\n    const recursiveTransform = (a, k) => {\n\n      if (typeof a[k] === 'string') {\n\n        a[k] = createTypeStore(a[k], size)\n        a[k][$storeBase] = () => stores[$store]\n        metadata[$storeFlattened].push(a[k])\n\n      } else if (isArrayType(a[k])) {\n        \n        const [type, length] = a[k]\n        a[k] = createArrayStore(metadata, type, length)\n        a[k][$storeBase] = () => stores[$store]\n        metadata[$storeFlattened].push(a[k])\n        // Object.seal(a[k])\n\n      } else if (a[k] instanceof Object) {\n        \n        a[k] = Object.keys(a[k]).reduce(recursiveTransform, a[k])\n        // Object.seal(a[k])\n        \n      }\n\n      return a\n    }\n\n    stores[$store] = Object.assign(Object.keys(schema).reduce(recursiveTransform, schema), metadata)\n    stores[$store][$storeBase] = () => stores[$store]\n\n    // Object.seal(stores[$store])\n\n    return stores[$store]\n\n  }\n}\n\nexport const free = (store) => {\n  delete stores[store[$storeRef]]\n}","export const Uint32SparseSet = (length) => {\n  const dense = new Uint32Array(length)\n  const sparse = new Uint32Array(length)\n\n  let cursor = 0\n  dense.count = () => cursor + 1\n\n  const has = val => dense[sparse[val]] === val\n\n  const add = val => {\n    if (has(val)) return\n    sparse[val] = cursor\n    dense[cursor] = val\n\n    cursor++\n  }\n\n  const remove = val => {\n    if (!has(val)) return\n    const index = sparse[val]\n    const swapped = dense[cursor]\n    if (swapped !== val) {\n      dense[index] = swapped\n      sparse[swapped] = index\n    }\n\n    cursor--\n  }\n\n  return {\n    add,\n    remove,\n    has,\n    sparse,\n    dense,\n  }\n}\n\nexport const SparseSet = () => {\n  const dense = []\n  const sparse = []\n\n  dense.sort = function (comparator) {\n    const result = Array.prototype.sort.call(this, comparator)\n\n    for(let i = 0; i < dense.length; i++) {\n      sparse[dense[i]] = i\n    }\n    \n    return result\n  }\n\n  const has = val => dense[sparse[val]] === val\n\n  const add = val => {\n    if (has(val)) return\n    sparse[val] = dense.push(val) - 1\n  }\n\n  const remove = val => {\n    if (!has(val)) return\n    const index = sparse[val]\n    const swapped = dense.pop()\n    if (swapped !== val) {\n      dense[index] = swapped\n      sparse[swapped] = index\n    }\n  }\n\n  return {\n    add,\n    remove,\n    has,\n    sparse,\n    dense,\n  }\n}","import { $indexBytes, $indexType, $isEidType, $serializeShadow, $storeBase, $storeFlattened, $tagStore, createShadow } from \"./Storage.js\"\nimport { $componentMap, addComponent, hasComponent } from \"./Component.js\"\nimport { $entityArray, $entitySparseSet, addEntity, eidToWorld } from \"./Entity.js\"\nimport { $localEntities, $localEntityLookup } from \"./World.js\"\nimport { SparseSet } from \"./Util.js\"\n\nexport const DESERIALIZE_MODE = {\n  REPLACE: 0,\n  APPEND: 1,\n  MAP: 2\n}\n\nlet resized = false\n\nexport const setSerializationResized = v => { resized = v }\n\nconst concat = (a,v) => a.concat(v)\nconst not = fn => v => !fn(v)\n\nconst storeFlattened = c => c[$storeFlattened]\nconst isFullComponent = storeFlattened\nconst isProperty = not(isFullComponent)\n\nconst isModifier = c => typeof c === 'function'\nconst isNotModifier = not(isModifier)\n\nconst isChangedModifier = c => isModifier(c) && c()[1] === 'changed'\n\nconst isWorld = w => Object.getOwnPropertySymbols(w).includes($componentMap)\n\nconst fromModifierToComponent = c => c()[0]\n\nexport const canonicalize = target => {\n\n  if (isWorld(target)) return [[],new Map()]\n\n  // aggregate full components\n  const fullComponentProps = target\n    .filter(isNotModifier)\n    .filter(isFullComponent)\n    .map(storeFlattened).reduce(concat, [])\n  \n  // aggregate changed full components\n  const changedComponentProps = target\n    .filter(isChangedModifier).map(fromModifierToComponent)\n    .filter(isFullComponent)\n    .map(storeFlattened).reduce(concat, [])\n\n  // aggregate props\n  const props = target\n    .filter(isNotModifier)\n    .filter(isProperty)\n\n  // aggregate changed props\n  const changedProps = target\n    .filter(isChangedModifier).map(fromModifierToComponent)\n    .filter(isProperty)\n  \n  const componentProps = [...fullComponentProps, ...props, ...changedComponentProps, ...changedProps]\n  const allChangedProps = [...changedComponentProps, ...changedProps].reduce((map,prop) => {\n    const $ = Symbol()\n    createShadow(prop, $)\n    map.set(prop, $)\n    return map\n  }, new Map())\n\n  return [componentProps, allChangedProps]\n}\n\n/**\n * Defines a new serializer which targets the given components to serialize the data of when called on a world or array of EIDs.\n *\n * @param {object|array} target\n * @param {number} [maxBytes=20000000]\n * @returns {function} serializer\n */\nexport const defineSerializer = (target, maxBytes = 20000000) => {\n  const worldSerializer = isWorld(target)\n\n  let [componentProps, changedProps] = canonicalize(target)\n\n  // TODO: calculate max bytes based on target & recalc upon resize\n\n  const buffer = new ArrayBuffer(maxBytes)\n  const view = new DataView(buffer)\n\n  const entityComponentCache = new Map()\n\n  return (ents) => {\n\n    if (resized) {\n      [componentProps, changedProps] = canonicalize(target)\n      resized = false\n    }\n\n    if (worldSerializer) {\n      componentProps = []\n      target[$componentMap].forEach((c, component) => {\n        if (component[$storeFlattened])\n          componentProps.push(...component[$storeFlattened])\n        else componentProps.push(component)\n      })\n    }\n    \n    let world\n    if (Object.getOwnPropertySymbols(ents).includes($componentMap)) {\n      world = ents\n      ents = ents[$entityArray]\n    } else {\n      world = eidToWorld.get(ents[0])\n    }\n\n    let where = 0\n\n    if (!ents.length) return buffer.slice(0, where)\n\n    const cache = new Map()\n\n    // iterate over component props\n    for (let pid = 0; pid < componentProps.length; pid++) {\n      const prop = componentProps[pid]\n      const component = prop[$storeBase]()\n      const $diff = changedProps.get(prop)\n      const shadow = $diff ? prop[$diff] : null\n\n      if (!cache.has(component)) cache.set(component, new Map())\n\n      // write pid\n      view.setUint8(where, pid)\n      where += 1\n\n      // save space for entity count\n      const countWhere = where\n      where += 4\n\n      let writeCount = 0\n      // write eid,val\n      for (let i = 0; i < ents.length; i++) {\n        const eid = ents[i]\n\n        let componentCache = entityComponentCache.get(eid)\n        if (!componentCache) componentCache = entityComponentCache.set(eid, new Set()).get(eid)\n        \n        componentCache.add(eid)\n        \n        const newlyAddedComponent = \n          // if we are diffing\n          shadow \n          // and we have already iterated over this component for this entity\n          // retrieve cached value    \n          && cache.get(component).get(eid)\n          // or if entity did not have component last call\n          || !componentCache.has(component)\n          // and entity has component this call\n          && hasComponent(world, component, eid)\n\n        cache.get(component).set(eid, newlyAddedComponent)\n\n        if (newlyAddedComponent) {\n          componentCache.add(component)\n        } else if (!hasComponent(world, component, eid)) {\n          // skip if entity doesn't have this component\n          componentCache.delete(component)\n          continue\n        } \n\n        \n        const rewindWhere = where\n\n        // write eid\n        view.setUint32(where, eid)\n        where += 4\n\n        // if it's a tag store we can stop here\n        if (prop[$tagStore]) {\n          writeCount++\n          continue\n        }\n\n        // if property is an array\n        if (ArrayBuffer.isView(prop[eid])) {\n          const type = prop[eid].constructor.name.replace('Array', '')\n          const indexType = prop[eid][$indexType]\n          const indexBytes = prop[eid][$indexBytes]\n\n          // save space for count of dirty array elements\n          const countWhere2 = where\n          where += indexBytes\n\n          let arrayWriteCount = 0\n\n          // write index,value\n          for (let i = 0; i < prop[eid].length; i++) {\n\n            if (shadow) {\n\n              const changed = shadow[eid][i] !== prop[eid][i]\n              \n              // sync shadow\n              shadow[eid][i] = prop[eid][i]              \n\n              // if state has not changed since the last call\n              // todo: if newly added then entire component will serialize (instead of only changed values)\n              if (!changed && !newlyAddedComponent) {\n                // skip writing this value\n                continue\n              }\n            }\n            \n            // write array index\n            view[`set${indexType}`](where, i)\n            where += indexBytes\n            \n            // write value at that index\n            const value = prop[eid][i]\n            view[`set${type}`](where, value)\n            where += prop[eid].BYTES_PER_ELEMENT\n            arrayWriteCount++\n          }\n\n          if (arrayWriteCount > 0) {\n            // write total element count\n            view[`set${indexType}`](countWhere2, arrayWriteCount)\n            writeCount++\n          } else {\n            where = rewindWhere\n            continue\n          }\n        } else {\n\n          if (shadow) {\n\n            const changed = shadow[eid] !== prop[eid]\n\n            shadow[eid] = prop[eid]\n\n            // do not write value if diffing and no change\n            if (!changed && !newlyAddedComponent) {\n              // rewind the serializer\n              where = rewindWhere\n              // skip writing this value\n              continue\n            }\n\n          }  \n\n\n          const type = prop.constructor.name.replace('Array', '')\n          // set value next [type] bytes\n          view[`set${type}`](where, prop[eid])\n          where += prop.BYTES_PER_ELEMENT\n\n          writeCount++\n        }\n      }\n\n      if (writeCount > 0) {\n        // write how many eid/value pairs were written\n        view.setUint32(countWhere, writeCount)\n      } else {\n        // if nothing was written (diffed with no changes) \n        // then move cursor back 5 bytes (remove PID and countWhere space)\n        where -= 5\n      }\n    }\n    return buffer.slice(0, where)\n  }\n}\n\nconst newEntities = new Map()\n\n/**\n * Defines a new deserializer which targets the given components to deserialize onto a given world.\n *\n * @param {object|array} target\n * @returns {function} deserializer\n */\nexport const defineDeserializer = (target) => {\n  const isWorld = Object.getOwnPropertySymbols(target).includes($componentMap)\n  let [componentProps] = canonicalize(target)\n\n  const deserializedEntities = new Set()\n\n  return (world, packet, mode=0) => {\n\n    newEntities.clear()\n    \n    if (resized) {\n      [componentProps] = canonicalize(target)\n      resized = false\n    }\n\n    if (isWorld) {\n      componentProps = []\n      target[$componentMap].forEach((c, component) => {\n        if (component[$storeFlattened])\n          componentProps.push(...component[$storeFlattened])\n        else componentProps.push(component)\n      })\n    }\n\n    const localEntities = world[$localEntities]\n    const localEntityLookup = world[$localEntityLookup]\n\n    const view = new DataView(packet)\n    let where = 0\n\n    while (where < packet.byteLength) {\n\n      // pid\n      const pid = view.getUint8(where)\n      where += 1\n\n      // entity count\n      const entityCount = view.getUint32(where)\n      where += 4\n\n      // component property\n      const prop = componentProps[pid]\n\n      // Get the entities and set their prop values\n      for (let i = 0; i < entityCount; i++) {\n        let eid = view.getUint32(where) // throws with [changed, c, changed]\n        where += 4\n\n        if (mode === DESERIALIZE_MODE.MAP) {\n          if (localEntities.has(eid)) {\n            eid = localEntities.get(eid)\n          } else if (newEntities.has(eid)) {\n            eid = newEntities.get(eid)\n          } else {\n            const newEid = addEntity(world)\n            localEntities.set(eid, newEid)\n            localEntityLookup.set(newEid, eid)\n            newEntities.set(eid, newEid)\n            eid = newEid\n          }\n        }\n\n        if (mode === DESERIALIZE_MODE.APPEND ||  \n          mode === DESERIALIZE_MODE.REPLACE && !world[$entitySparseSet].has(eid)\n        ) {\n          const newEid = newEntities.get(eid) || addEntity(world)\n          newEntities.set(eid, newEid)\n          eid = newEid\n        }\n\n        const component = prop[$storeBase]()\n        if (!hasComponent(world, component, eid)) {\n          addComponent(world, component, eid)\n        }\n\n        // add eid to deserialized ents after it has been transformed by MAP mode\n        deserializedEntities.add(eid)\n\n        if (component[$tagStore]) {\n          continue\n        }\n        \n        if (ArrayBuffer.isView(prop[eid])) {\n          const array = prop[eid]\n          const count = view[`get${array[$indexType]}`](where)\n          where += array[$indexBytes]\n\n          // iterate over count\n          for (let i = 0; i < count; i++) {\n            const index = view[`get${array[$indexType]}`](where)\n            where += array[$indexBytes]\n\n            const value = view[`get${array.constructor.name.replace('Array', '')}`](where)\n            where += array.BYTES_PER_ELEMENT\n            if (prop[$isEidType]) {\n              let localEid\n              if (localEntities.has(value)) {\n                localEid = localEntities.get(value)\n              } else if (newEntities.has(value)) {\n                localEid = newEntities.get(value)\n              } else {\n                const newEid = addEntity(world)\n                localEntities.set(value, newEid)\n                localEntityLookup.set(newEid, value)\n                newEntities.set(value, newEid)\n                localEid = newEid\n              }\n              prop[eid][index] = localEid\n            } else prop[eid][index] = value\n          }\n        } else {\n          const value = view[`get${prop.constructor.name.replace('Array', '')}`](where)\n          where += prop.BYTES_PER_ELEMENT\n\n          if (prop[$isEidType]) {\n            let localEid\n            if (localEntities.has(value)) {\n              localEid = localEntities.get(value)\n            } else if (newEntities.has(value)) {\n              localEid = newEntities.get(value)\n            } else {\n              const newEid = addEntity(world)\n              localEntities.set(value, newEid)\n              localEntityLookup.set(newEid, value)\n              newEntities.set(value, newEid)\n              localEid = newEid\n            }\n            prop[eid] = localEid\n          } else prop[eid] = value\n        }\n      }\n    }\n\n    const ents = Array.from(deserializedEntities)\n\n    deserializedEntities.clear()\n\n    return ents\n  }\n}","import { resizeComponents } from './Component.js'\nimport { $notQueries, $queries, queryAddEntity, queryCheckEntity, queryRemoveEntity } from './Query.js'\nimport { $localEntities, $localEntityLookup, resizeWorlds } from './World.js'\nimport { setSerializationResized } from './Serialize.js'\n\nexport const $entityMasks = Symbol('entityMasks')\nexport const $entityComponents = Symbol('entityComponents')\nexport const $entitySparseSet = Symbol('entitySparseSet')\nexport const $entityArray = Symbol('entityArray')\nexport const $entityIndices = Symbol('entityIndices')\nexport const $removedEntities = Symbol('removedEntities')\n\nlet defaultSize = 100000\n\n// need a global EID cursor which all worlds and all components know about\n// so that world entities can posess entire rows spanning all component tables\nlet globalEntityCursor = 0\nlet globalSize = defaultSize\nlet resizeThreshold = () => globalSize - (globalSize / 5)\n\nexport const getGlobalSize = () => globalSize\n\n// removed eids should also be global to prevent memory leaks\nconst removed = []\n\nexport const resetGlobals = () => {\n  globalSize = defaultSize\n  globalEntityCursor = 0\n  removed.length = 0\n}\n\nexport const getDefaultSize = () => defaultSize\n\n/**\n * Sets the default maximum number of entities for worlds and component stores.\n *\n * @param {number} newSize\n */\nexport const setDefaultSize = newSize => { \n  const oldSize = globalSize\n\n  defaultSize = newSize\n  resetGlobals()\n\n  globalSize = newSize\n  resizeWorlds(newSize)\n  resizeComponents(newSize)\n  setSerializationResized(true)\n\n  console.info(` bitECS - resizing all data stores from ${oldSize} to ${newSize}`)\n}\n\nexport const getEntityCursor = () => globalEntityCursor\nexport const getRemovedEntities = () => removed\n\nexport const eidToWorld = new Map()\n\n/**\n * Adds a new entity to the specified world.\n *\n * @param {World} world\n * @returns {number} eid\n */\nexport const addEntity = (world) => {\n\n  // if data stores are 80% full\n  if (globalEntityCursor >= resizeThreshold()) {\n    // grow by half the original size rounded up to a multiple of 4\n    const size = globalSize\n    const amount = Math.ceil((size/2) / 4) * 4\n    setDefaultSize(size + amount)\n  }\n  \n  const eid = removed.length > Math.round(defaultSize * 0.01) ? removed.shift() : globalEntityCursor++\n  \n  world[$entitySparseSet].add(eid)\n  eidToWorld.set(eid, world)\n\n  world[$notQueries].forEach(q => {\n    const match = queryCheckEntity(world, q, eid)\n    if (match) queryAddEntity(q, eid)\n  })\n\n  world[$entityComponents].set(eid, new Set())\n\n  return eid\n}\n\n/**\n * Removes an existing entity from the specified world.\n *\n * @param {World} world\n * @param {number} eid\n */\nexport const removeEntity = (world, eid) => {\n  // Check if entity is already removed\n  if (!world[$entitySparseSet].has(eid)) return\n\n  // Remove entity from all queries\n  // TODO: archetype graph\n  world[$queries].forEach(q => {\n    queryRemoveEntity(world, q, eid)\n  })\n\n  // Free the entity\n  removed.push(eid)\n\n  // remove all eid state from world\n  world[$entitySparseSet].remove(eid)\n  world[$entityComponents].delete(eid)\n\n  // remove from deserializer mapping\n  world[$localEntities].delete(world[$localEntityLookup].get(eid))\n  world[$localEntityLookup].delete(eid)\n\n  // Clear entity bitmasks\n  for (let i = 0; i < world[$entityMasks].length; i++) world[$entityMasks][i][eid] = 0\n}\n\n/**\n *  Returns an array of components that an entity possesses.\n *\n * @param {*} world\n * @param {*} eid\n */\nexport const getEntityComponents = (world, eid) => {\n  if (eid === undefined) throw new Error('bitECS - entity is undefined.')\n  if (!world[$entitySparseSet].has(eid)) throw new Error('bitECS - entity does not exist in the world.')\n  return Array.from(world[$entityComponents].get(eid))\n}\n\n/**\n * Checks the existence of an entity in a world\n * \n * @param {World} world \n * @param {number} eid \n */\nexport const entityExists = (world, eid) => world[$entitySparseSet].has(eid)","import { SparseSet } from './Util.js'\nimport { $queryShadow, $storeFlattened, $tagStore, createShadow } from './Storage.js'\nimport { $componentMap, registerComponent } from './Component.js'\nimport { $entityMasks, $entityArray, getEntityCursor, $entitySparseSet } from './Entity.js'\n\n\n\nexport function Not(c) { return () => [c, 'not'] }\nexport function Or(c) { return () => [c, 'or'] }\nexport function Changed(c) { return () => [c, 'changed'] }\n\nexport function Any(...comps) { return function QueryAny() { return comps } }\nexport function All(...comps) { return function QueryAll() { return comps } }\nexport function None(...comps) { return function QueryNone() { return comps } }\n\nexport const $queries = Symbol('queries')\nexport const $notQueries = Symbol('notQueries')\n\nexport const $queryAny = Symbol('queryAny')\nexport const $queryAll = Symbol('queryAll')\nexport const $queryNone = Symbol('queryNone')\n\nexport const $queryMap = Symbol('queryMap')\nexport const $dirtyQueries = Symbol('$dirtyQueries')\nexport const $queryComponents = Symbol('queryComponents')\nexport const $enterQuery = Symbol('enterQuery')\nexport const $exitQuery = Symbol('exitQuery')\n\n/**\n * Given an existing query, returns a new function which returns entities who have been added to the given query since the last call of the function.\n *\n * @param {function} query\n * @returns {function} enteredQuery\n */\nexport const enterQuery = query => world => {\n  if (!world[$queryMap].has(query)) registerQuery(world, query)\n  const q = world[$queryMap].get(query)\n  // queryCommitRemovals(q)\n  const entered = q.entered.dense.slice()\n  q.entered = SparseSet()\n  return entered\n}\n\n/**\n * Given an existing query, returns a new function which returns entities who have been removed from the given query since the last call of the function.\n *\n * @param {function} query\n * @returns {function} enteredQuery\n */\nexport const exitQuery = query => world => {\n  if (!world[$queryMap].has(query)) registerQuery(world, query)\n  const q = world[$queryMap].get(query)\n  // queryCommitRemovals(q)\n  const exited = q.exited.dense.slice()\n  q.exited = SparseSet()\n  return exited\n}\n\nexport const registerQuery = (world, query) => {\n\n  const components = []\n  const notComponents = []\n  const changedComponents = []\n\n  query[$queryComponents].forEach(c => {\n    if (typeof c === 'function') {\n      const [comp, mod] = c()\n      if (!world[$componentMap].has(comp)) registerComponent(world, comp)\n      if (mod === 'not') {\n        notComponents.push(comp)\n      }\n      if (mod === 'changed') {\n        changedComponents.push(comp)\n        components.push(comp)\n      }\n      // if (mod === 'all') {\n      //   allComponents.push(comp)\n      // }\n      // if (mod === 'any') {\n      //   anyComponents.push(comp)\n      // }\n      // if (mod === 'none') {\n      //   noneComponents.push(comp)\n      // }\n    } else {\n      if (!world[$componentMap].has(c)) registerComponent(world, c)\n      components.push(c)\n    }\n  })\n\n\n  const mapComponents = c => world[$componentMap].get(c)\n\n  const allComponents = components.concat(notComponents).map(mapComponents)\n\n  // const sparseSet = Uint32SparseSet(getGlobalSize())\n  const sparseSet = SparseSet()\n\n  const archetypes = []\n  // const changed = SparseSet()\n  const changed = []\n  const toRemove = SparseSet()\n  const entered = SparseSet()\n  const exited = SparseSet()\n\n  const generations = allComponents\n    .map(c => c.generationId)\n    .reduce((a,v) => {\n      if (a.includes(v)) return a\n      a.push(v)\n      return a\n    }, [])\n\n  const reduceBitflags = (a,c) => {\n    if (!a[c.generationId]) a[c.generationId] = 0\n    a[c.generationId] |= c.bitflag\n    return a\n  }\n  const masks = components\n    .map(mapComponents)\n    .reduce(reduceBitflags, {})\n\n  const notMasks = notComponents\n    .map(mapComponents)\n    .reduce(reduceBitflags, {})\n\n  // const orMasks = orComponents\n  //   .map(mapComponents)\n  //   .reduce(reduceBitmasks, {})\n\n  const hasMasks = allComponents\n    .reduce(reduceBitflags, {})\n\n  const flatProps = components\n    .filter(c => !c[$tagStore])\n    .map(c => Object.getOwnPropertySymbols(c).includes($storeFlattened) ? c[$storeFlattened] : [c])\n    .reduce((a,v) => a.concat(v), [])\n\n  const shadows = []\n\n  const q = Object.assign(sparseSet, {\n    archetypes,\n    changed,\n    components,\n    notComponents,\n    changedComponents,\n    allComponents,\n    masks,\n    notMasks,\n    // orMasks,\n    hasMasks,\n    generations,\n    flatProps,\n    toRemove,\n    entered,\n    exited,\n    shadows,\n  })\n\n  world[$queryMap].set(query, q)\n  world[$queries].add(q)\n  \n  allComponents.forEach(c => {\n    c.queries.add(q)\n  })\n\n  if (notComponents.length) world[$notQueries].add(q)\n\n  for (let eid = 0; eid < getEntityCursor(); eid++) {\n    if (!world[$entitySparseSet].has(eid)) continue\n    const match = queryCheckEntity(world, q, eid)\n    if (match) queryAddEntity(q, eid)\n  }\n}\n\nconst generateShadow = (q, pid) => {\n  const $ = Symbol()\n  const prop = q.flatProps[pid]\n  createShadow(prop, $)\n  q.shadows[pid] = prop[$]\n  return prop[$]\n}\n\nconst diff = (q, clearDiff) => {\n  if (clearDiff) q.changed = []\n  const { flatProps, shadows } = q\n  for (let i = 0; i < q.dense.length; i++) {\n    const eid = q.dense[i]\n    let dirty = false\n    for (let pid = 0; pid < flatProps.length; pid++) {\n      const prop = flatProps[pid]\n      const shadow = shadows[pid] || generateShadow(q, pid)\n      if (ArrayBuffer.isView(prop[eid])) {\n        for (let i = 0; i < prop[eid].length; i++) {\n          if (prop[eid][i] !== shadow[eid][i]) {\n            dirty = true\n            break\n          }\n        }\n        shadow[eid].set(prop[eid])\n      } else {\n        if (prop[eid] !== shadow[eid]) {\n          dirty = true\n          shadow[eid] = prop[eid]\n        }\n      }\n    }\n    if (dirty) q.changed.push(eid)\n  }\n  return q.changed\n}\n\n// const queryEntityChanged = (q, eid) => {\n//   if (q.changed.has(eid)) return\n//   q.changed.add(eid)\n// }\n\n// export const entityChanged = (world, component, eid) => {\n//   const { changedQueries } = world[$componentMap].get(component)\n//   changedQueries.forEach(q => {\n//     const match = queryCheckEntity(world, q, eid)\n//     if (match) queryEntityChanged(q, eid)\n//   })\n// }\n\nconst flatten = (a,v) => a.concat(v)\n\nconst aggregateComponentsFor = mod => x => x.filter(f => f.name === mod().constructor.name).reduce(flatten)\n\nconst getAnyComponents = aggregateComponentsFor(Any)\nconst getAllComponents = aggregateComponentsFor(All)\nconst getNoneComponents = aggregateComponentsFor(None)\n\n/**\n * Defines a query function which returns a matching set of entities when called on a world.\n *\n * @param {array} components\n * @returns {function} query\n */\n\nexport const defineQuery = (...args) => {\n  let components\n  let any, all, none\n  if (Array.isArray(args[0])) {\n    components = args[0]\n  } else {\n    // any = getAnyComponents(args)\n    // all = getAllComponents(args)\n    // none = getNoneComponents(args)\n  }\n  \n\n  if (components === undefined || components[$componentMap] !== undefined) {\n    return world => world ? world[$entityArray] : components[$entityArray]\n  }\n\n  const query = function (world, clearDiff=true) {\n    if (!world[$queryMap].has(query)) registerQuery(world, query)\n\n    const q = world[$queryMap].get(query)\n\n    commitRemovals(world)\n\n    if (q.changedComponents.length) return diff(q, clearDiff)\n    // if (q.changedComponents.length) return q.changed.dense\n\n    return q.dense\n  }\n\n  query[$queryComponents] = components\n  query[$queryAny] = any\n  query[$queryAll] = all\n  query[$queryNone] = none\n\n  return query\n}\n\nconst bin = value => {\n  if (!Number.isSafeInteger(value)) {\n    throw new TypeError('value must be a safe integer');\n  }\n\n  const negative = value < 0;\n  const twosComplement = negative ? Number.MAX_SAFE_INTEGER + value + 1 : value;\n  const signExtend = negative ? '1' : '0';\n\n  return twosComplement.toString(2).padStart(4, '0').padStart(0, signExtend);\n}\n\n// TODO: archetype graph\nexport const queryCheckEntity = (world, q, eid) => {\n  const { masks, notMasks, generations } = q\n  let or = 0\n  for (let i = 0; i < generations.length; i++) {\n    const generationId = generations[i]\n    const qMask = masks[generationId]\n    const qNotMask = notMasks[generationId]\n    // const qOrMask = orMasks[generationId]\n    const eMask = world[$entityMasks][generationId][eid]\n    \n    // any\n    // if (qOrMask && (eMask & qOrMask) !== qOrMask) {\n    //   continue\n    // }\n    // not all \n    // if (qNotMask && (eMask & qNotMask) === qNotMask) {\n    // }\n    // not any\n    if (qNotMask && (eMask & qNotMask) !== 0) {\n      return false\n    }\n    // all\n    if (qMask && (eMask & qMask) !== qMask) {\n      return false\n    }\n  }\n  return true\n}\n\nexport const queryCheckComponent = (q, c) => {\n  const { generationId, bitflag } = c\n  const { hasMasks } = q\n  const mask = hasMasks[generationId]\n  return (mask & bitflag) === bitflag\n}\n\nexport const queryAddEntity = (q, eid) => {\n  q.toRemove.remove(eid)\n  // if (!q.has(eid)) \n  q.entered.add(eid)\n  q.add(eid)\n}\n\nconst queryCommitRemovals = (q) => {\n  for (let i = q.toRemove.dense.length-1; i >= 0; i--) {\n    const eid = q.toRemove.dense[i]\n    q.toRemove.remove(eid)\n    q.remove(eid)\n  }\n}\n\nexport const commitRemovals = (world) => {\n  if (!world[$dirtyQueries].size) return\n  world[$dirtyQueries].forEach(queryCommitRemovals)\n  world[$dirtyQueries].clear()\n}\n\nexport const queryRemoveEntity = (world, q, eid) => {\n  if (!q.has(eid) || q.toRemove.has(eid)) return\n  q.toRemove.add(eid)\n  world[$dirtyQueries].add(q)\n  q.exited.add(eid)\n}\n\n\n/**\n * Resets a Changed-based query, clearing the underlying list of changed entities.\n *\n * @param {World} world\n * @param {function} query\n */\nexport const resetChangedQuery = (world, query) => {\n  const q = world[$queryMap].get(query)\n  q.changed = []\n}\n\n/**\n * Removes a query from a world.\n *\n * @param {World} world\n * @param {function} query\n */\nexport const removeQuery = (world, query) => {\n  const q = world[$queryMap].get(query)\n  world[$queries].delete(q)\n  world[$queryMap].delete(query)\n}","import { $storeSize, createStore, resetStoreFor, resizeStore } from './Storage.js'\nimport { $queries, queryAddEntity, queryRemoveEntity, queryCheckEntity, commitRemovals } from './Query.js'\nimport { $bitflag, $size } from './World.js'\nimport { $entityMasks, getDefaultSize, eidToWorld, $entityComponents, getGlobalSize, $entitySparseSet } from './Entity.js'\n\nexport const $componentMap = Symbol('componentMap')\n\nexport const components = []\n\nexport const resizeComponents = (size) => {\n  components.forEach(component => resizeStore(component, size))\n}\n\n\n/**\n * Defines a new component store.\n *\n * @param {object} schema\n * @returns {object}\n */\nexport const defineComponent = (schema, size) => {\n  const component = createStore(schema, size || getGlobalSize())\n  if (schema && Object.keys(schema).length) components.push(component)\n  return component\n}\n\nexport const incrementBitflag = (world) => {\n  world[$bitflag] *= 2\n  if (world[$bitflag] >= 2**31) {\n    world[$bitflag] = 1\n    world[$entityMasks].push(new Uint32Array(world[$size]))\n  }\n}\n\n\n/**\n * Registers a component with a world.\n *\n * @param {World} world\n * @param {Component} component\n */\nexport const registerComponent = (world, component) => {\n  if (!component) throw new Error(`bitECS - Cannot register null or undefined component`)\n\n  const queries = new Set()\n  const notQueries = new Set()\n  const changedQueries = new Set()\n\n  world[$queries].forEach(q => {\n    if (q.allComponents.includes(component)) {\n      queries.add(q)\n    }\n  })\n\n  world[$componentMap].set(component, { \n    generationId: world[$entityMasks].length - 1,\n    bitflag: world[$bitflag],\n    store: component,\n    queries,\n    notQueries,\n    changedQueries,\n  })\n\n  if (component[$storeSize] < getGlobalSize()) {\n    resizeStore(component, getGlobalSize())\n  }\n\n  incrementBitflag(world)\n}\n\n/**\n * Registers multiple components with a world.\n *\n * @param {World} world\n * @param {Component} components\n */\nexport const registerComponents = (world, components) => {\n  components.forEach(c => registerComponent(world, c))\n}\n\n/**\n * Checks if an entity has a component.\n *\n * @param {World} world\n * @param {Component} component\n * @param {number} eid\n * @returns {boolean}\n */\nexport const hasComponent = (world, component, eid) => {\n  const registeredComponent = world[$componentMap].get(component)\n  if (!registeredComponent) return false\n  const { generationId, bitflag } = registeredComponent\n  const mask = world[$entityMasks][generationId][eid]\n  return (mask & bitflag) === bitflag\n}\n\n/**\n * Adds a component to an entity\n *\n * @param {World} world\n * @param {Component} component\n * @param {number} eid\n * @param {boolean} [reset=false]\n */\nexport const addComponent = (world, component, eid, reset=false) => {\n  if (eid === undefined) throw new Error('bitECS - entity is undefined.')\n  if (!world[$entitySparseSet].has(eid)) throw new Error('bitECS - entity does not exist in the world.')\n  if (!world[$componentMap].has(component)) registerComponent(world, component)\n  if (hasComponent(world, component, eid)) return\n\n  const c = world[$componentMap].get(component)\n  const { generationId, bitflag, queries, notQueries } = c\n    \n  // Add bitflag to entity bitmask\n  world[$entityMasks][generationId][eid] |= bitflag\n\n  // todo: archetype graph\n  queries.forEach(q => {\n    // remove this entity from toRemove if it exists in this query\n    if (q.toRemove.has(eid)) q.toRemove.remove(eid)\n    const match = queryCheckEntity(world, q, eid)\n    if (match) queryAddEntity(q, eid)\n    if (!match) queryRemoveEntity(world, q, eid)\n  })\n\n  world[$entityComponents].get(eid).add(component)\n\n  // Zero out each property value\n  if (reset) resetStoreFor(component, eid)\n}\n\n/**\n * Removes a component from an entity and resets component state unless otherwise specified.\n *\n * @param {World} world\n * @param {Component} component\n * @param {number} eid\n * @param {boolean} [reset=true]\n */\nexport const removeComponent = (world, component, eid, reset=true) => {\n  if (eid === undefined) throw new Error('bitECS - entity is undefined.')\n  if (!world[$entitySparseSet].has(eid)) throw new Error('bitECS - entity does not exist in the world.')\n  if (!hasComponent(world, component, eid)) return\n\n  const c = world[$componentMap].get(component)\n  const { generationId, bitflag, queries } = c\n\n  // Remove flag from entity bitmask\n  world[$entityMasks][generationId][eid] &= ~bitflag\n  \n  // todo: archetype graph\n  queries.forEach(q => {\n    // remove this entity from toRemove if it exists in this query\n    if (q.toRemove.has(eid)) q.toRemove.remove(eid)\n    const match = queryCheckEntity(world, q, eid)\n    if (match) queryAddEntity(q, eid)\n    if (!match) queryRemoveEntity(world, q, eid)\n  })\n\n  world[$entityComponents].get(eid).delete(component)\n\n  // Zero out each property value\n  if (reset) resetStoreFor(component, eid)\n}\n","import { $componentMap } from './Component.js'\nimport { $queryMap, $queries, $dirtyQueries, $notQueries } from './Query.js'\nimport { $entityArray, $entityComponents, $entityMasks, $entitySparseSet, getGlobalSize, removeEntity } from './Entity.js'\nimport { resize } from './Storage.js'\nimport { SparseSet } from './Util.js'\n\nexport const $size = Symbol('size')\nexport const $resizeThreshold = Symbol('resizeThreshold')\nexport const $bitflag = Symbol('bitflag')\nexport const $archetypes = Symbol('archetypes')\nexport const $localEntities = Symbol('localEntities')\nexport const $localEntityLookup = Symbol('localEntityLookp')\n\nexport const worlds = []\n\nexport const resizeWorlds = (size) => {\n  worlds.forEach(world => {\n    world[$size] = size\n\n    for (let i = 0; i < world[$entityMasks].length; i++) {\n      const masks = world[$entityMasks][i];\n      world[$entityMasks][i] = resize(masks, size)\n    }\n    \n    world[$resizeThreshold] = world[$size] - (world[$size] / 5)\n  })\n}\n\n/**\n * Creates a new world.\n *\n * @returns {object}\n */\nexport const createWorld = (...args) => {\n  const world = typeof args[0] === 'object'\n    ? args[0]\n    : {}\n  const size = typeof args[0] === 'number' \n    ? args[0] \n    : typeof args[1] === 'number' \n      ? args[1] \n      : getGlobalSize()\n  resetWorld(world, size)\n  worlds.push(world)\n  return world\n}\n\n/**\n * Resets a world.\n *\n * @param {World} world\n * @returns {object}\n */\nexport const resetWorld = (world, size = getGlobalSize()) => {\n  world[$size] = size\n\n  if (world[$entityArray]) world[$entityArray].forEach(eid => removeEntity(world, eid))\n\n  world[$entityMasks] = [new Uint32Array(size)]\n  world[$entityComponents] = new Map()\n  world[$archetypes] = []\n\n  world[$entitySparseSet] = SparseSet()\n  world[$entityArray] = world[$entitySparseSet].dense\n\n  world[$bitflag] = 1\n\n  world[$componentMap] = new Map()\n\n  world[$queryMap] = new Map()\n  world[$queries] = new Set()\n  world[$notQueries] = new Set()\n  world[$dirtyQueries] = new Set()\n\n  world[$localEntities] = new Map()\n  world[$localEntityLookup] = new Map()\n\n  return world\n}\n\n/**\n * Deletes a world.\n *\n * @param {World} world\n */\nexport const deleteWorld = (world) => {\n  Object.getOwnPropertySymbols(world).forEach($ => { delete world[$] })\n  Object.keys(world).forEach(key => { delete world[key] })\n  worlds.splice(worlds.indexOf(world), 1)\n}\n\n/**\n * Returns all components registered to a world\n * \n * @param {World} world \n * @returns Array\n */\nexport const getWorldComponents = (world) => Array.from(world[$componentMap].keys())\n\n/**\n * Returns all existing entities in a world\n * \n * @param {World} world \n * @returns Array\n */\nexport const getAllEntities = (world) => world[$entitySparseSet].dense.slice(0)","import { createWorld, resetWorld, deleteWorld, getWorldComponents } from './World.js'\nimport { addEntity, removeEntity, setDefaultSize, getEntityComponents, entityExists } from './Entity.js'\nimport { defineComponent, registerComponent, registerComponents, hasComponent, addComponent, removeComponent } from './Component.js'\nimport { defineSystem } from './System.js'\nimport { defineQuery, enterQuery, exitQuery, Changed, Not, commitRemovals, resetChangedQuery, removeQuery } from './Query.js'\nimport { defineSerializer, defineDeserializer, DESERIALIZE_MODE } from './Serialize.js'\nimport { parentArray } from './Storage.js'\nimport { TYPES_ENUM } from './Constants.js'\n\nexport const pipe = (...fns) => (input) => {\n  let tmp = input\n  for (let i = 0; i < fns.length; i++) {\n    const fn = fns[i]\n    tmp = fn(tmp)\n  }\n  return tmp\n}\n\nexport const Types = TYPES_ENUM\n\nexport {\n\n  setDefaultSize,\n  createWorld,\n  resetWorld,\n  deleteWorld,\n  addEntity,\n  removeEntity,\n  entityExists,\n  getWorldComponents,\n  \n  registerComponent,\n  registerComponents,\n  defineComponent,\n  addComponent,\n  removeComponent,\n  hasComponent,\n  getEntityComponents,\n\n  defineQuery,\n  Changed,\n  Not,\n  enterQuery,\n  exitQuery,\n  commitRemovals,\n  resetChangedQuery,\n  removeQuery,\n\n  defineSystem,\n  \n  defineSerializer,\n  defineDeserializer,\n  DESERIALIZE_MODE,\n\n  parentArray,\n\n}\n","import { addComponent, addEntity, Component } from 'bitecs';\nimport { EventEmitter } from 'eventemitter3';\nimport World from './world';\n\nexport default class Entity extends EventEmitter {\n\tworld: World;\n\teid: number;\n\n\t// Position\n\tget x()    { return this.world.components.position.x[this.eid]; }\n\tset x(val) { this.world.components.position.x[this.eid] = val; }\n\tget y()    { return this.world.components.position.y[this.eid]; }\n\tset y(val) { this.world.components.position.y[this.eid] = val; }\n\tget width()    { return this.world.components.position.width[this.eid]; }\n\tset width(val) { this.world.components.position.width[this.eid] = val; }\n\tget height()    { return this.world.components.position.height[this.eid]; }\n\tset height(val) { this.world.components.position.height[this.eid] = val; }\n\n\t// Health\n\tget shields()    { return this.world.components.health.shields[this.eid]; }\n\tset shields(val) { this.world.components.health.shields[this.eid] = val; }\n\tget maxShields()    { return this.world.components.health.maxShields[this.eid]; }\n\tset maxShields(val) { this.world.components.health.maxShields[this.eid] = val; }\n\tget timeToRegenerateShields()    { return this.world.components.health.timeToRegenerateShields[this.eid]; }\n\tset timeToRegenerateShields(val) { this.world.components.health.timeToRegenerateShields[this.eid] = val; }\n\tget timeSinceShieldRegeneration()    { return this.world.components.health.timeSinceShieldRegeneration[this.eid]; }\n\tset timeSinceShieldRegeneration(val) { this.world.components.health.timeSinceShieldRegeneration[this.eid] = val; }\n\tget timeSinceTakenDamage()    { return this.world.components.health.timeSinceTakenDamage[this.eid]; }\n\tset timeSinceTakenDamage(val) { this.world.components.health.timeSinceTakenDamage[this.eid] = val; }\n\tget dead()    { return this.world.components.health.shields[this.eid]; }\n\tset dead(val) { this.world.components.health.shields[this.eid] = val; }\n\n\ttype = 'entity';\n\tkey = 'boid';\n\n\tconstructor(world: World) {\n\t\tsuper();\n\t\tthis.eid = addEntity(world.ecs);\n\t\tthis.world = world;\n\n\t\tthis.addComponent(world.components.position);\n\t\tthis.addComponent(world.components.health);\n\n\t\tthis.shields = 1;\n\t\tthis.maxShields = 1;\n\t\tthis.timeToRegenerateShields = 1;\n\t\tthis.timeSinceShieldRegeneration = 0;\n\t\tthis.timeSinceTakenDamage = 0;\n\t\tthis.dead = 0;\n\t}\n\n\tload(config: any) {\n\t\t// TODO: Need a way which does not rely on manually setup get/set.  Maybe in our own system define how it is serialized as part of the component registration?\n\t\tObject.keys(config).forEach((key: string) => {\n\t\t\t// @ts-expect-error\n\t\t\tthis[key] = config[key];\n\t\t});\n\t}\n\n\tset(component: 'string', name: 'string', value: any) {\n\t\t// @ts-expect-error\n\t\tthis.world.components[component][name][this.eid] = value;\n\t}\n\n\tprotected addComponent(component: Component) {\n\t\taddComponent(this.world.ecs, component, this.eid);\n\t}\n}","import Entity from './entity';\nimport World from './world';\n\nexport default class Station extends Entity {\n\tget color()    { return this.world.components.controller.color[this.eid]; }\n\tset color(val) { this.world.components.controller.color[this.eid] = val; }\n\tget money()    { return this.world.components.controller.money[this.eid]; }\n\tset money(val) { this.world.components.controller.money[this.eid] = val; }\n\n\tconstructor(world: World) {\n\t\tsuper(world);\n\t\tthis.addComponent(world.components.controller);\n\n\t\tthis.key = 'station';\n\t\tthis.width = 20;\n\t\tthis.height = 20;\n\t\tthis.shields = 2;\n\t\tthis.maxShields = 2;\n\t\tthis.timeToRegenerateShields = 5;\n\t}\n}","import Entity from './entity';\nimport Station from './station';\n\nexport default class Ship extends Entity {\n\tget color()    { return this.world.components.controller.color[this.world.components.controlled.owner[this.eid]]; }\n\n\tget velocityX()    { return this.world.components.velocity.x[this.eid]; }\n\tset velocityX(val) { this.world.components.velocity.x[this.eid] = val; }\n\tget velocityY()    { return this.world.components.velocity.y[this.eid]; }\n\tset velocityY(val) { this.world.components.velocity.y[this.eid] = val; }\n\n\tget station() { return this.world.getEntity(this.eid); }\n\n\tconstructor(station: Station) {\n\t\tsuper(station.world);\n\n\t\tlet world = station.world;\n\t\tthis.addComponent(world.components.velocity);\n\t\tthis.addComponent(world.components.controlled);\n\t\tthis.addComponent(world.components.attack);\n\t\t\n\t\tthis.width = 10;\n\t\tthis.height = 5;\n\t\tthis.shields = 1;\n\t\tthis.maxShields = 1;\n\t\tthis.timeToRegenerateShields = 1;\n\t\tthis.world.components.velocity.speed[this.eid] = 100;\n\t\tworld.components.controlled.owner[this.eid] = station.eid;\n\t}\n}","import computeAngle from '@/math/compute-angle';\nimport { defineQuery, IWorld } from 'bitecs';\nimport Ship from '../entities/ship';\nimport Station from '../entities/station';\nimport World from '../entities/world';\n\nexport default function spawnShipSystem(world: World) {\n\tconst controller = world.components.controller;\n\tconst health = world.components.health;\n\tlet stationQuery = defineQuery([controller]);\n\n\treturn (ecs: IWorld) => {\n\t\t// TODO: Remove dependency on our containers so this could realistically be running in a simple worker with just duplicated data\n\t\tlet stations = stationQuery(ecs).filter(eid => !health.dead[eid]);\n\t\tstations.forEach(stationEid => {\n\t\t\tlet station = world.getEntity(stationEid) as Station;\n\t\t\tif(controller.money[stationEid] > 0) {\n\t\t\t\tlet ship = new Ship(station);\n\t\t\t\tship.x = station.x;\n\t\t\t\tship.y = station.y;\n\t\t\t\tship.velocityX = (Math.random() > 0.5 ? -1 : 1) * Math.random() * world.components.velocity.speed[ship.eid];\n\t\t\t\tship.velocityY = (Math.random() > 0.5 ? -1 : 1) * Math.random() * world.components.velocity.speed[ship.eid];\n\t\t\t\tworld.components.position.angle[ship.eid] = computeAngle(ship.velocityX, ship.velocityY);\n\n\t\t\t\tworld.addEntity(ship);\n\t\t\t\tcontroller.money[stationEid]--;\n\t\t\t}\n\t\t});\n\n\t\treturn ecs;\n\t};\n}","import { Types } from 'bitecs';\n\nexport default {\n\tx: Types.f32,\n\ty: Types.f32,\n\twidth: Types.f32,\n\theight: Types.f32,\n\tangle: Types.f32\n};","import { Types } from 'bitecs';\n\nexport default {\n\tcolor: Types.f32,\n\tmoney: Types.i32\n};","import { Types } from 'bitecs';\n\nexport default {\n\tx: Types.f32,\n\ty: Types.f32,\n\tspeed: Types.f32\n};","import { Types } from 'bitecs';\n\nexport default {\n\tshields: Types.i32,\n\tmaxShields: Types.i32,\n\ttimeToRegenerateShields: Types.f32,\n\ttimeSinceShieldRegeneration: Types.f32,\n\ttimeSinceTakenDamage: Types.f32,\n\tdead: Types.ui8\n};","import { Types } from 'bitecs';\n\nexport default {\n\towner: Types.eid\n};","import { Types } from 'bitecs';\n\nexport default {\n\ttarget: Types.eid\n};","import {\n\tdefineComponent\n} from 'bitecs';\nimport position from './position';\nimport controller from './controller';\nimport velocity from './velocity';\nimport health from './health';\nimport controlled from './controlled';\nimport attack from './attack';\n\nexport default {\n\tposition: defineComponent(position),\n\tcontroller: defineComponent(controller),\n\tvelocity: defineComponent(velocity),\n\thealth: defineComponent(health),\n\tcontrolled: defineComponent(controlled),\n\tattack: defineComponent(attack)\n};","import computeAngle from '@/math/compute-angle';\nimport { defineQuery, IWorld } from 'bitecs';\nimport World from '../entities/world';\n\nexport default function velocitySystem(world: World) {\n\tconst position = world.components.position;\n\tconst velocity = world.components.velocity;\n\tlet shipQuery = defineQuery([position, velocity]);\n\n\treturn (ecs: IWorld, delta: number) => {\n\t\tlet ships = shipQuery(ecs);\n\t\tships.forEach(shipEid => {\n\t\t\tposition.x[shipEid] += velocity.x[shipEid] * delta;\n\t\t\tposition.y[shipEid] += velocity.y[shipEid] * delta;\n\n\t\t\t// TODO: Don't reference proxy world directly\n\t\t\tif(position.x[shipEid] < 0 || position.x[shipEid] > world.bounds.width) {\n\t\t\t\tvelocity.x[shipEid] = -velocity.x[shipEid];\n\t\t\t\tposition.angle[shipEid] = computeAngle(velocity.x[shipEid], velocity.y[shipEid]);\n\t\t\t}\n\t\n\t\t\tif(position.y[shipEid] < 0 || position.y[shipEid] > world.bounds.height) {\n\t\t\t\tvelocity.y[shipEid] = -velocity.y[shipEid];\n\t\t\t\tposition.angle[shipEid] = computeAngle(velocity.x[shipEid], velocity.y[shipEid]);\n\t\t\t}\n\t\t});\n\n\t\treturn ecs;\n\t};\n}","import { defineQuery, hasComponent, IWorld } from 'bitecs';\nimport World from '../entities/world';\nimport { Rectangle } from '@timohausmann/quadtree-ts/src/index.esm';\nimport distance from '@/math/distance';\nimport computeAngle from '@/math/compute-angle';\n\nexport default function collisionSystem(world: World) {\n\tconst position = world.components.position;\n\tconst velocity = world.components.velocity;\n\tconst controlled = world.components.controlled;\n\tconst controller = world.components.controller;\n\tconst health = world.components.health;\n\tlet movingQuery = defineQuery([velocity]);\n\n\t// 60fps = 0.016 so 30fps is roughly 0.032 so basically every other frame\n\tconst TIME_BETWEEN_TICKS = 0.03;\n\tlet timeSinceLastTick = TIME_BETWEEN_TICKS + 1;\n\tlet ships: Array<number> = [];\n\tlet minCountToUpdate = 0;\n\treturn (ecs: IWorld, delta: number) => {\n\t\ttimeSinceLastTick += delta;\n\t\tif(timeSinceLastTick > TIME_BETWEEN_TICKS && ships.length === 0) {\n\t\t\tships = movingQuery(ecs).filter(eid => !health.dead[eid]);\n\t\t\tminCountToUpdate = ships.length / 2;\n\t\t\ttimeSinceLastTick = 0;\n\t\t}\n\n\t\t// @ts-expect-error\n\t\tlet quadtree = ecs.quadtree;\n\t\tlet start = performance.now();\n\n\t\t// Use quadtree to see who we are colliding with\n\t\tfor(let i = 0; i < ships.length; i++) {\n\t\t\tlet eid = ships[i];\n\t\t\tlet entitiesInRange = quadtree.retrieve(new Rectangle({\n\t\t\t\tx: position.x[eid],\n\t\t\t\ty: position.y[eid],\n\t\t\t\twidth: position.width[eid],\n\t\t\t\theight: position.height[eid]\n\t\t\t})).map((result: any) => result.data.eid).filter((otherEid: number) => otherEid !== eid);\n\t\t\tlet shipColor = controller.color[controlled.owner[eid]];\n\t\t\tlet enemiesInRange = entitiesInRange.filter((otherEid: number) => {\n\t\t\t\t// Ship\n\t\t\t\tif(hasComponent(ecs, controlled, otherEid)) {\n\t\t\t\t\tlet stationEid = controlled.owner[otherEid];\n\t\t\t\t\treturn controller.color[stationEid] !== shipColor;\n\t\t\t\t}\n\t\t\t\t// Station\n\t\t\t\telse if(hasComponent(ecs, controller, otherEid)) {\n\t\t\t\t\treturn controller.color[otherEid] !== shipColor;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t\tlet collisions = enemiesInRange.filter((otherEid: number) => distance(position.x[otherEid], position.y[otherEid], position.x[eid], position.y[eid]) < Math.max(position.width[eid], position.width[otherEid]));\n\t\t\tif(collisions.length) {\n\t\t\t\tcollide(world, ships, eid, collisions[0]);\n\n\t\t\t\tvelocity.x[eid] = -velocity.x[eid];\n\t\t\t\tvelocity.y[eid] = -velocity.y[eid];\n\t\t\t\tposition.angle[eid] = computeAngle(velocity.x[eid], velocity.y[eid]);\n\t\t\t}\n\n\t\t\tif(i % 10 === 0 && i > minCountToUpdate) {\n\t\t\t\tif(performance.now() - start > (delta * 1_000 / 2)) {\n\t\t\t\t\tships = ships.slice(i);\n\t\t\t\t\treturn ecs;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tships = [];\n\t\treturn ecs;\n\t};\n}\n\nfunction collide(world: World, ships: Array<number>, eid: number, target: number) {\n\tif(!canTakeDamage(world, eid) || !canTakeDamage(world, target)) {\n\t\treturn;\n\t}\n\n\tlet enemyWorth = 1;\n\tif(hasComponent(world.ecs, world.components.controller, target)) {\n\t\tenemyWorth = ships.filter(eid => world.components.controlled.owner[eid] === target).length;\n\t}\n\n\ttakeDamage(world, ships, eid, 1);\n\ttakeDamage(world, ships, target, 1);\n\n\tconst controlled = world.components.controlled;\n\tif(world.components.health.dead[target]) {\n\t\tlet stationEid = controlled.owner[eid];\n\t\tworld.components.controller.money[stationEid] += enemyWorth;\n\t}\n\tif(world.components.health.dead[eid]) {\n\t\t// Ship\n\t\tif(hasComponent(world.ecs, controlled, target)) {\n\t\t\tlet stationEid = controlled.owner[target];\n\t\t\tworld.components.controller.money[stationEid] += 1;\n\t\t}\n\t\t// Station\n\t\telse if(hasComponent(world.ecs, world.components.controller, target)) {\n\t\t\tworld.components.controller.money[target] += 1;\n\t\t}\n\t}\n}\nfunction takeDamage(world: World, ships: Array<number>, eid: number, damage: number) {\n\tconst health = world.components.health;\n\thealth.shields[eid] -= damage;\n\thealth.timeSinceTakenDamage[eid] = 0;\n\tif(health.shields[eid] < 0) {\n\t\thealth.dead[eid] = 1;\n\n\t\t// TODO: Removing makes it so our change query doesn't detect that these are gone\n\t\t// world.removeEntity(eid);\n\t\tif(hasComponent(world.ecs, world.components.controller, eid)) {\n\t\t\tlet controlledShips = ships.filter(shipEid => world.components.controlled.owner[shipEid] === eid);\n\t\t\tcontrolledShips.forEach(shipEid => {\n\t\t\t\thealth.dead[shipEid] = 1;\n\t\t\t});\n\t\t}\n\t}\n}\n\nfunction canTakeDamage(world: World, eid: number) {\n\treturn world.components.health.timeSinceTakenDamage[eid] >= 0.2;\n}","import { defineQuery, hasComponent, IWorld } from 'bitecs';\nimport World from '../entities/world';\nimport { Rectangle } from '@timohausmann/quadtree-ts/src/index.esm';\nimport euclideanDistance from '@/math/euclidean-distance';\n\nexport default function targetEnemySystem(world: World) {\n\tconst position = world.components.position;\n\tconst velocity = world.components.velocity;\n\tconst controlled = world.components.controlled;\n\tconst controller = world.components.controller;\n\tconst health = world.components.health;\n\tconst attack = world.components.attack;\n\tlet movingQuery = defineQuery([velocity, attack]);\n\tlet controllerQuery = defineQuery([controller]);\n\n\tconst TIME_BETWEEN_TICKS = 0.2;\n\tlet timeSinceLastTick = TIME_BETWEEN_TICKS + 1;\n\tlet movingEntities: Array<number> = [];\n\tlet minCountToUpdate = 0;\n\treturn (ecs: IWorld, delta: number) => {\n\t\t// Run through all of entities eventually, but don't have more than half a frame's time to do a block of them\n\t\ttimeSinceLastTick += delta;\n\t\tif(timeSinceLastTick > TIME_BETWEEN_TICKS && movingEntities.length === 0) {\n\t\t\tmovingEntities = movingQuery(ecs).filter(eid => !health.dead[eid]);\n\t\t\tminCountToUpdate = movingEntities.length / (TIME_BETWEEN_TICKS / delta);\n\t\t\ttimeSinceLastTick = 0;\n\t\t}\n\n\t\t// @ts-expect-error\n\t\tlet quadtree = ecs.quadtree;\n\t\tlet start = performance.now();\n\n\t\t// Use quadtree to see who we are colliding with\n\t\tfor(let i = 0; i < movingEntities.length; i++) {\n\t\t\tlet eid = movingEntities[i];\n\t\t\tlet shipColor = controller.color[controlled.owner[eid]];\n\n\t\t\t// Try to find the nearest enemy\n\t\t\tlet rect = {\n\t\t\t\tx: position.x[eid] - 50,\n\t\t\t\ty: position.y[eid] - 50,\n\t\t\t\twidth: position.width[eid] + 100,\n\t\t\t\theight: position.height[eid] + 100\n\t\t\t};\n\t\t\tlet enemies = getEnemiesInRange(quadtree, ecs, rect, eid, shipColor, world);\n\t\t\tif(enemies.length === 0) {\n\t\t\t\trect.x -= 100;\n\t\t\t\trect.y -= 100;\n\t\t\t\trect.width += 200;\n\t\t\t\trect.height += 200;\n\t\t\t\tenemies = getEnemiesInRange(quadtree, ecs, rect, eid, shipColor, world);\n\t\t\t}\n\t\n\t\t\tenemies.sort((a, b) => {\n\t\t\t\treturn euclideanDistance(position.x[a], position.y[a], position.x[eid], position.y[eid]) - euclideanDistance(position.x[b], position.y[b], position.x[eid], position.y[eid]);\n\t\t\t});\n\t\t\tlet enemy = enemies[0] ?? 0;\n\n\t\t\t// If no enemies that quadtree could easily find, just head for the nearest station\n\t\t\tif(!enemy) {\n\t\t\t\tlet stations = controllerQuery(ecs).filter(stationEid => controller.color[stationEid] !== shipColor && !health.dead[stationEid]);\n\t\t\t\tstations.sort((a, b) => {\n\t\t\t\t\treturn euclideanDistance(position.x[a], position.y[a], position.x[eid], position.y[eid]) - euclideanDistance(position.x[b], position.y[b], position.x[eid], position.y[eid]);\n\t\t\t\t});\n\n\t\t\t\tenemy = stations[0] ?? 0;\n\t\t\t}\n\n\t\t\tattack.target[eid] = enemy;\n\n\t\t\tif(i % 10 === 0 && i > minCountToUpdate) {\n\t\t\t\t// Check how long we have been running for\n\t\t\t\tif(performance.now() - start > (delta * 1_000 / 2)) {\n\t\t\t\t\tmovingEntities = movingEntities.slice(i);\n\t\t\t\t\treturn ecs;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmovingEntities = [];\n\t\treturn ecs;\n\t};\n}\n\nfunction getEnemiesInRange(quadtree: any, ecs: IWorld, range: { x: number, y: number, width: number, height: number }, eid: number, shipColor: number, world: World) : Array<number> {\n\tconst controlled = world.components.controlled;\n\tconst controller = world.components.controller;\n\n\tlet entitiesInRange = quadtree.retrieve(new Rectangle(range)).map((result: any) => result.data.eid).filter((otherEid: number) => otherEid !== eid);\n\treturn entitiesInRange.filter((otherEid: number) => {\n\t\t// Ship\n\t\tif(hasComponent(ecs, controlled, otherEid)) {\n\t\t\tlet stationEid = controlled.owner[otherEid];\n\t\t\treturn controller.color[stationEid] !== shipColor;\n\t\t}\n\t\t// Station\n\t\telse if(hasComponent(ecs, controller, otherEid)) {\n\t\t\treturn controller.color[otherEid] !== shipColor;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t});\n}","import { defineQuery, IWorld } from 'bitecs';\nimport World from '../entities/world';\nimport { Quadtree, Rectangle } from '@timohausmann/quadtree-ts/src/index.esm';\n\nexport default function createQuadTreeSystem(world: World) {\n\tconst position = world.components.position;\n\tconst health = world.components.health;\n\tlet collidableQuery = defineQuery([position, health]);\n\n\treturn (ecs: IWorld) => {\n\t\t// Create and populate quadtree\n\t\tlet quadtree = new Quadtree({\n\t\t\twidth: world.bounds.width,\n\t\t\theight: world.bounds.height\n\t\t});\n\t\tcollidableQuery(ecs).forEach(eid => {\n\t\t\tif(health.dead[eid]) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tquadtree.insert(new Rectangle({\n\t\t\t\tx: position.x[eid],\n\t\t\t\ty: position.y[eid],\n\t\t\t\twidth: position.width[eid],\n\t\t\t\theight: position.height[eid],\n\t\t\t\tdata: {\n\t\t\t\t\teid\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\n\t\t// @ts-expect-error\n\t\tecs.quadtree = quadtree;\n\n\t\treturn ecs;\n\t};\n}","import { defineQuery, IWorld } from 'bitecs';\nimport World from '../entities/world';\n\nexport default function updateHealthTimersSystem(world: World) {\n\tconst health = world.components.health;\n\tlet healthQuery = defineQuery([health]);\n\n\treturn (ecs: IWorld, delta: number) => {\n\t\thealthQuery(ecs).forEach(eid => {\n\t\t\thealth.timeSinceTakenDamage[eid] += delta;\n\n\t\t\tif(health.shields[eid] < health.maxShields[eid]) {\n\t\t\t\thealth.timeSinceShieldRegeneration[eid] += delta;\n\t\t\t\tif(health.timeSinceShieldRegeneration[eid] > health.timeToRegenerateShields[eid]) {\n\t\t\t\t\thealth.shields[eid]++;\n\t\t\t\t\thealth.timeSinceShieldRegeneration[eid] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn ecs;\n\t};\n}","import { defineQuery, IWorld } from 'bitecs';\nimport World from '../entities/world';\nimport computeAngle from '@/math/compute-angle';\nconst PhaserMath = require('phaser/src/math');\n\nexport default function moveToTargetSystem(world: World) {\n\tconst position = world.components.position;\n\tconst velocity = world.components.velocity;\n\tconst attack = world.components.attack;\n\tconst health = world.components.health;\n\tlet movingQuery = defineQuery([velocity, attack]);\n\n\treturn (ecs: IWorld) => {\n\t\tmovingQuery(ecs).forEach(eid => {\n\t\t\tlet target = attack.target[eid];\n\t\t\tif(!target || health.dead[target]) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet force = getMoveTowardsForce(position, eid, target);\n\t\t\tlet newVelocity = new PhaserMath.Vector2(velocity.x[eid] + force.x * 4, velocity.y[eid] + force.y * 4);\n\t\t\tnewVelocity.normalize();\n\n\t\t\tvelocity.x[eid] = newVelocity.x * velocity.speed[eid];\n\t\t\tvelocity.y[eid] = newVelocity.y * velocity.speed[eid];\n\t\t\tposition.angle[eid] = computeAngle(velocity.x[eid], velocity.y[eid]);\n\t\t});\n\n\t\treturn ecs;\n\t};\n}\n\nfunction getMoveTowardsForce(position: any, eid: number, otherEid: number) {\n\tlet force = new PhaserMath.Vector2(position.x[otherEid] - position.x[eid], position.y[otherEid] - position.y[eid]);\n\tforce.normalize();\n\treturn force;\n}","import {\n\tcreateWorld,\n\tIWorld,\n\tremoveEntity\n} from 'bitecs';\nimport Entity from './entity';\nimport { EventEmitter } from 'eventemitter3';\nimport Station from './station';\nimport spawnShipSystem from '../systems/spawn-ship-system';\nimport components from '../components';\nimport velocitySystem from '../systems/velocity-system';\nimport collisionSystem from '../systems/collision-system';\nimport targetEnemySystem from '../systems/target-enemy-system';\nimport createQuadTreeSystem from '../systems/create-quad-tree-system';\nimport updateHealthTimersSystem from '../systems/update-health-timers-system';\nimport moveToTargetSystem from '../systems/move-to-target-system';\n\nexport default class World extends EventEmitter {\n\tecs: IWorld;\n\teidMap: Map<number, Entity> = new Map();\n\tbounds: {\n\t\twidth: number,\n\t\theight: number\n\t} = { width: 0, height: 0 };\n\tcomponents = components;\n\tsystems: Array<(world: IWorld, delta: number) => IWorld> = [];\n\tsystemUpdates: { [s: string]: Array<number> } = {};\n\n\tget entities() { return [...this.eidMap.values()]; }\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.ecs = createWorld();\n\n\t\tthis.addSystem('quadTreeSystem', createQuadTreeSystem(this));\n\t\tthis.addSystem('spawnShipSystem', spawnShipSystem(this));\n\t\tthis.addSystem('targetEnemySystem', targetEnemySystem(this));\n\t\tthis.addSystem('moveToTargetSystem', moveToTargetSystem(this));\n\t\tthis.addSystem('velocitySystem', velocitySystem(this));\n\t\tthis.addSystem('collisionSystem', collisionSystem(this));\n\t\tthis.addSystem('updateHealthTimersSystem', updateHealthTimersSystem(this));\n\t}\n\n\tload(config: any) {\n\t\tconfig.entities.forEach((entityConfig: any) => {\n\t\t\tlet entity;\n\t\t\tswitch(entityConfig.type) {\n\t\t\t\tcase 'station':\n\t\t\t\t\tentity = new Station(this);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tentity = new Entity(this);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentity.load(entityConfig);\n\t\t\tthis.addEntity(entity);\n\t\t});\n\n\t\tif(config.bounds) {\n\t\t\tthis.bounds = config.bounds;\n\t\t}\n\t}\n\taddEntity(entity: Entity) {\n\t\tthis.emit('entity-added', entity);\n\t\tthis.eidMap.set(entity.eid, entity);\n\t}\n\tremoveEntity(eid: number) {\n\t\tremoveEntity(this.ecs, eid);\n\t\tthis.eidMap.delete(eid);\n\t}\n\tgetEntity(eid: number) {\n\t\treturn this.eidMap.get(eid) ?? null;\n\t}\n\n\tupdate(delta: number) {\n\t\tthis.systems.forEach(system => {\n\t\t\tsystem(this.ecs, delta);\n\t\t});\n\t}\n\n\taddSystem(name: string, update: (world: IWorld, delta: number) => void) {\n\t\tthis.systems.push((world: IWorld, delta: number) => {\n\t\t\tlet start = performance.now();\n\t\t\tupdate(world, delta);\n\t\t\tthis.systemUpdates[name].push(performance.now() - start);\n\n\t\t\treturn world;\n\t\t});\n\t\tthis.systemUpdates[name] = [];\n\t}\n}","import { defineComponent as _defineComponent } from 'vue'\nimport { toDisplayString as _toDisplayString, createElementVNode as _createElementVNode, unref as _unref, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, normalizeStyle as _normalizeStyle, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\"\n\nconst _withScopeId = n => (_pushScopeId(\"data-v-4e495fc6\"),n=n(),_popScopeId(),n)\nconst _hoisted_1 = { class: \"home\" }\nconst _hoisted_2 = { class: \"list\" }\nconst _hoisted_3 = { style: {\"color\":\"red\"} }\nconst _hoisted_4 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(\"p\", null, null, -1))\nconst _hoisted_5 = /*#__PURE__*/ _withScopeId(() => /*#__PURE__*/_createElementVNode(\"div\", { id: \"phaser-container-bitecs\" }, null, -1))\n\nimport { ref, onMounted, onBeforeUnmount, Ref } from 'vue';\nimport Phaser from 'phaser';\nimport generateScene from '@/data/generate-scene';\nimport World from './entities/world';\nimport Entity from './entities/entity';\nimport Station from './entities/station';\nimport Ship from './entities/ship';\nimport { Changed, defineQuery } from 'bitecs';\nimport components from './components';\n\n\nexport default /*#__PURE__*/_defineComponent({\n  setup(__props) {\n\nlet world = new World();\nconst minUpdateTime = ref(0);\nconst maxUpdateTime = ref(0);\nconst avgUpdateTime = ref(0);\nconst stationsCount = ref(0);\nconst shipsCount = ref(0);\nconst stationShips = ref([]) as Ref<Array<{ eid: number, color: number, displayColor: string, ships: number }>>;\nconst stationQuery = defineQuery([components.controller]);\nconst systemUpdates = ref([]) as Ref<Array<{ name: string, min: number, avg: number, max: number }>>;\n\nlet game: Phaser.Game | null;\nonMounted(() => {\n\tlet updateTicks = 0;\n\tlet updateTimes: Array<number> = [];\n\n\tconst width = window.innerWidth / 3 * 2;\n\tconst height = window.innerHeight / 3 * 2;\n\tlet paused = false;\n\tconst changedPositionQuery = defineQuery([ Changed(components.position) ]);\n\tconst changedHealthQuery = defineQuery([ Changed(components.health) ]);\n\tconst controlledQuery = defineQuery([components.controlled]);\n\tconst eidSpriteMap = new Map<number, any>();\n\tgame = new Phaser.Game({\n\t\ttype: Phaser.AUTO,\n\t\twidth,\n\t\theight,\n\t\tparent: 'phaser-container-bitecs',\n\t\t// @ts-expect-error\n\t\tscene: {\n\t\t\tpreload() {\n\t\t\t\tthis.load.image('boid', 'boid.png');\n\t\t\t\tthis.load.image('station', 'station.png');\n\t\t\t\tthis.load.image('shield', 'shield3.png');\n\t\t\t},\n\t\t\tcreate() {\n\t\t\t\tworld.on('entity-added', (entity: Entity) => {\n\t\t\t\t\tlet image = this.add.image(entity.x, entity.y, entity.key) as any;\n\t\t\t\t\timage.setScale(entity.width / image.width, entity.height / image.height);\n\t\t\t\t\timage.shieldImage = this.add.image(entity.x, entity.y, 'shield');\n\t\t\t\t\timage.shieldImage.setScale(entity.width / image.shieldImage.width * 2, entity.height / image.shieldImage.height * 2);\n\t\t\t\t\timage.shieldImage.visible = entity.shields > 0;\n\t\t\t\t\tif(entity instanceof Station || entity instanceof Ship) {\n\t\t\t\t\t\timage.setTint(entity.color);\n\t\t\t\t\t}\n\t\t\t\t\teidSpriteMap.set(entity.eid, image);\n\t\t\t\t});\n\n\t\t\t\tworld.load(generateScene({\n\t\t\t\t\tstations: 6,\n\t\t\t\t\tshipsPerStation: 100,\n\t\t\t\t\twidth,\n\t\t\t\t\theight\n\t\t\t\t}));\n\n\t\t\t\tlet stations = world.entities.filter(entity => entity instanceof Station) as Array<Station>;\n\t\t\t\tstationShips.value = stations.map(station => {\n\t\t\t\t\tlet displayColor = '#' + station.color.toString(16);\n\t\t\t\t\tif(displayColor === '#ffffff') {\n\t\t\t\t\t\tdisplayColor = '#00000';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\teid: station.eid,\n\t\t\t\t\t\tcolor: station.color,\n\t\t\t\t\t\tdisplayColor,\n\t\t\t\t\t\tships: 0\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\tthis.input.keyboard.on('keydown-SPACE', () => {\n\t\t\t\t\tpaused = !paused;\n\t\t\t\t});\n\n\t\t\t\tObject.keys(world.systemUpdates).forEach(systemName => {\n\t\t\t\t\tsystemUpdates.value.push({\n\t\t\t\t\t\tname: systemName,\n\t\t\t\t\t\tmin:0,\n\t\t\t\t\t\tavg: 0,\n\t\t\t\t\t\tmax: 0\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\t\t\tupdate(time: number, delta: number) {\n\t\t\t\tif(paused) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet start = performance.now();\n\t\t\t\tworld.update(delta / 1_000);\n\n\t\t\t\tchangedPositionQuery(world.ecs).forEach(eid => {\n\t\t\t\t\tlet image = eidSpriteMap.get(eid);\n\t\t\t\t\tif(!image) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\timage.x = image.shieldImage.x = components.position.x[eid];\n\t\t\t\t\timage.y = image.shieldImage.y = components.position.y[eid];\n\t\t\t\t\timage.angle = image.shieldImage.angle = components.position.angle[eid];\n\t\t\t\t});\n\t\t\t\tchangedHealthQuery(world.ecs).forEach(eid => {\n\t\t\t\t\tlet image = eidSpriteMap.get(eid);\n\t\t\t\t\tif(!image) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\timage.shieldImage.visible = components.health.shields[eid] > 0;\n\t\t\t\t\tif(components.health.dead[eid]) {\n\t\t\t\t\t\timage.destroy();\n\t\t\t\t\t\timage.shieldImage.destroy();\n\t\t\t\t\t\teidSpriteMap.delete(eid);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tlet end = performance.now();\n\n\t\t\t\tupdateTimes.push(end - start);\n\t\t\t\tupdateTicks += delta;\n\t\t\t\tif(updateTicks > 1_000) {\n\t\t\t\t\tminUpdateTime.value = updateTimes.reduce((min, time) => {\n\t\t\t\t\t\treturn Math.min(min, time);\n\t\t\t\t\t}, 1_000_000);\n\t\t\t\t\tmaxUpdateTime.value = updateTimes.reduce((max, time) => {\n\t\t\t\t\t\treturn Math.max(max, time);\n\t\t\t\t\t}, 0);\n\t\t\t\t\tavgUpdateTime.value = updateTimes.reduce((total, time) => {\n\t\t\t\t\t\treturn total + time;\n\t\t\t\t\t}, 0) / updateTimes.length;\n\t\t\t\t\tupdateTimes = [];\n\t\t\t\t\tupdateTicks = 0;\n\n\t\t\t\t\tstationsCount.value = world.entities.filter(entity => entity instanceof Station).length;\n\n\t\t\t\t\tlet stations = stationQuery(world.ecs).filter(eid => !components.health.dead[eid]);\n\t\t\t\t\tlet ships = controlledQuery(world.ecs).filter(eid => !components.health.dead[eid]);\n\t\t\t\t\tshipsCount.value = ships.length;\n\t\t\t\t\tstationShips.value.forEach(val => {\n\t\t\t\t\t\tlet matchingStationEid = stations.find(eid => components.controller.color[eid] === val.color);\n\t\t\t\t\t\tif(matchingStationEid !== undefined) {\n\t\t\t\t\t\t\tval.ships = ships.filter(eid => components.controlled.owner[eid] === val.eid).length;\n\t\t\t\t\t\t} else if(val.ships > 0) {\n\t\t\t\t\t\t\t// paused = true;\n\t\t\t\t\t\t\tval.ships = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tsystemUpdates.value = [];\n\t\t\t\t\tObject.keys(world.systemUpdates).forEach(systemName => {\n\t\t\t\t\t\tlet updates = world.systemUpdates[systemName];\n\n\t\t\t\t\t\tsystemUpdates.value.push({\n\t\t\t\t\t\t\tname: systemName,\n\t\t\t\t\t\t\tmin: updates.reduce((min, time) => {\n\t\t\t\t\t\t\t\treturn Math.min(min, time);\n\t\t\t\t\t\t\t}, 1_000_000),\n\t\t\t\t\t\t\tavg: updates.reduce((total, time) => {\n\t\t\t\t\t\t\t\treturn total + time;\n\t\t\t\t\t\t\t}, 0) / updates.length,\n\t\t\t\t\t\t\tmax: updates.reduce((max, time) => {\n\t\t\t\t\t\t\t\treturn Math.max(max, time);\n\t\t\t\t\t\t\t}, 0)\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tworld.systemUpdates[systemName] = [];\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n});\nonBeforeUnmount(() => {\n\tif(game) {\n\t\tgame.destroy();\n\t\tgame = null;\n\t} \n});\n\nfunction addShips() {\n\tstationQuery(world.ecs).forEach(eid => {\n\t\tworld.components.controller.money[eid] += 10;\n\t});\n}\n\nreturn (_ctx: any,_cache: any) => {\n  return (_openBlock(), _createElementBlock(\"div\", _hoisted_1, [\n    _createElementVNode(\"div\", _hoisted_2, [\n      _createElementVNode(\"div\", _hoisted_3, \"mainThread: \" + _toDisplayString(maxUpdateTime.value.toFixed(2)) + \" (\" + _toDisplayString(avgUpdateTime.value.toFixed(2)) + \" avg) ms\", 1),\n      (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(systemUpdates), (system) => {\n        return (_openBlock(), _createElementBlock(\"div\", {\n          key: system.name\n        }, _toDisplayString(system.name) + \": \" + _toDisplayString(system.max.toFixed(2)) + \" (\" + _toDisplayString(system.avg.toFixed(2)) + \" avg) ms\", 1))\n      }), 128)),\n      _hoisted_4,\n      _createElementVNode(\"div\", null, \"Entities: \" + _toDisplayString(stationsCount.value) + \" stations and \" + _toDisplayString(shipsCount.value) + \" ships\", 1),\n      (_openBlock(true), _createElementBlock(_Fragment, null, _renderList(_unref(stationShips), (station) => {\n        return (_openBlock(), _createElementBlock(\"span\", {\n          class: \"station-list\",\n          key: station.color,\n          style: _normalizeStyle({ color: station.displayColor })\n        }, _toDisplayString('#' + station.color.toString(16)) + \": \" + _toDisplayString(station.ships), 5))\n      }), 128)),\n      _createElementVNode(\"div\", null, [\n        _createElementVNode(\"button\", { onClick: addShips }, \"Add Ships\")\n      ])\n    ]),\n    _hoisted_5\n  ]))\n}\n}\n\n})","import script from \"./BitECSGame.vue?vue&type=script&setup=true&lang=ts\"\nexport * from \"./BitECSGame.vue?vue&type=script&setup=true&lang=ts\"\n\nimport \"./BitECSGame.vue?vue&type=style&index=0&id=4e495fc6&scoped=true&lang=css\"\n\nimport exportComponent from \"/home/runner/work/ecs-arraybuffer/ecs-arraybuffer/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['__scopeId',\"data-v-4e495fc6\"]])\n\nexport default __exports__"],"names":["TYPES_ENUM","i8","ui8","ui8c","i16","ui16","i32","ui32","f32","f64","eid","TYPES_NAMES","TYPES","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","UNSIGNED_MAX","uint8","uint16","uint32","roundToMultiple","mul","x","Math","ceil","roundToMultiple4","$storeRef","Symbol","$storeSize","$storeMaps","$storeFlattened","$storeBase","$storeType","$storeArrayElementCounts","$storeSubarrays","$subarrayCursors","$subarray","$parentArray","$tagStore","$indexType","$indexBytes","$isEidType","stores","resize","ta","size","newBuffer","ArrayBuffer","BYTES_PER_ELEMENT","newTa","constructor","set","createShadow","store","key","isView","slice","shadowStore","map","_","length","start","end","subarray","resizeSubarray","metadata","storeSize","cursors","type","indexType","arrayElementCount","array","start2","end2","resizeRecursive","Object","keys","forEach","Array","isArray","push","resizeStore","k","resetStoreFor","fill","createTypeStore","totalBytes","buffer","createArrayStore","Error","isArrayType","createStore","schema","$store","JSON","parse","stringify","arrayElementCounts","collectArrayElementCounts","s","reduce","a","recursiveTransform","assign","SparseSet","dense","sparse","sort","comparator","result","prototype","call","this","i","has","val","add","remove","index","swapped","pop","setSerializationResized","v","not","fn","storeFlattened","c","isFullComponent","isModifier","$entityMasks","$entityComponents","$entitySparseSet","$entityArray","defaultSize","globalEntityCursor","globalSize","resizeThreshold","getGlobalSize","removed","resetGlobals","setDefaultSize","newSize","oldSize","resizeWorlds","resizeComponents","console","info","getEntityCursor","eidToWorld","Map","addEntity","world","amount","round","shift","$notQueries","q","match","queryCheckEntity","queryAddEntity","Set","removeEntity","$queries","queryRemoveEntity","delete","$localEntities","$localEntityLookup","get","Changed","Any","comps","All","None","$queryAny","$queryAll","$queryNone","$queryMap","$dirtyQueries","$queryComponents","registerQuery","query","components2","notComponents","changedComponents","comp","mod","$componentMap","registerComponent","mapComponents","allComponents","concat","sparseSet","archetypes","changed","toRemove","entered","exited","generations","generationId","includes","reduceBitflags","bitflag","masks","notMasks","hasMasks","flatProps","filter","getOwnPropertySymbols","shadows","components","queries","generateShadow","pid","$","prop","diff","clearDiff","dirty","shadow","i2","flatten","aggregateComponentsFor","f","name","defineQuery","args","any","all","none","commitRemovals","qMask","qNotMask","eMask","queryCommitRemovals","clear","component","defineComponent","incrementBitflag","$bitflag","$size","notQueries","changedQueries","hasComponent","registeredComponent","mask","addComponent","reset","$resizeThreshold","$archetypes","worlds","createWorld","resetWorld","Types","Entity","EventEmitter","position","y","width","height","shields","health","maxShields","timeToRegenerateShields","timeSinceShieldRegeneration","timeSinceTakenDamage","dead","super","ecs","load","config","value","Station","color","controller","money","Ship","controlled","owner","velocityX","velocity","velocityY","station","getEntity","attack","speed","spawnShipSystem","stationQuery","stations","stationEid","ship","random","angle","computeAngle","target","velocitySystem","shipQuery","delta","ships","shipEid","bounds","collisionSystem","movingQuery","TIME_BETWEEN_TICKS","timeSinceLastTick","minCountToUpdate","quadtree","performance","now","entitiesInRange","retrieve","Rectangle","data","otherEid","shipColor","enemiesInRange","collisions","distance","max","collide","canTakeDamage","enemyWorth","takeDamage","damage","controlledShips","targetEnemySystem","controllerQuery","movingEntities","rect","enemies","getEnemiesInRange","b","euclideanDistance","enemy","range","createQuadTreeSystem","collidableQuery","Quadtree","insert","updateHealthTimersSystem","healthQuery","PhaserMath","require","moveToTargetSystem","force","getMoveTowardsForce","newVelocity","Vector2","normalize","World","entities","eidMap","values","addSystem","entityConfig","entity","emit","update","systems","system","systemUpdates","_withScopeId","n","_pushScopeId","_popScopeId","_hoisted_1","class","_hoisted_2","_hoisted_3","style","_hoisted_4","_createElementVNode","_hoisted_5","id","_defineComponent","setup","__props","minUpdateTime","ref","maxUpdateTime","avgUpdateTime","stationsCount","shipsCount","stationShips","game","addShips","onMounted","updateTicks","updateTimes","window","innerWidth","innerHeight","paused","changedPositionQuery","changedHealthQuery","controlledQuery","eidSpriteMap","Phaser","parent","scene","preload","image","create","on","setScale","shieldImage","visible","setTint","generateScene","shipsPerStation","displayColor","toString","input","keyboard","systemName","min","avg","time","destroy","total","matchingStationEid","find","undefined","updates","onBeforeUnmount","_ctx","_cache","_openBlock","_createElementBlock","_toDisplayString","toFixed","_Fragment","_renderList","_unref","_normalizeStyle","onClick","__exports__"],"sourceRoot":""}